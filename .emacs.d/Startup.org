#+TITLE: My Emacs Startup
#+STARTUP: overview
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :tangle init.el
#+TODO: | DISABLED
#+TODO: TODO | DONE

* Overview

  This is my fourth attempt at a decent emacs startup script. I have tried a
  single ~.emacs~, small scattered files in ~.emacs.d~, late loading
  configuration files using a custom method, and finally, ~use-package~
  replacing the custom late loading method.

  Now I have decided to leverage [[http://orgmode.org/][org-mode]] outline and search capabilities, and
  collapse all the scattered files into a single literate startup file.

* License

  All the code I have in this file is free software. This also goes for the
  generated =init.el= file.

  #+begin_src emacs-lisp
    ;; Copyright 2017, Ahmet Vedat Hallac
    ;;
    ;; This program is free software: you can redistribute it and/or modify
    ;; it under the terms of the GNU General Public License as published by
    ;; the Free Software Foundation, either version 3 of the License, or
    ;; (at your option) any later version.
    ;;
    ;; This program is distributed in the hope that it will be useful,
    ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ;; GNU General Public License for more details.
    ;;
    ;; You should have received a copy of the GNU General Public License
    ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  #+end_src

* How to Use this file

  This file contains configuration script snippets organized by different type
  of headings. In order to be able to keep things seperate, I will try to
  minimize the use of package/variable customization using ~customize-group~ or
  ~customize-variable~.

  Each snippet is an org mode source block. Each block can be edited in a
  separate buffer by pressing =C-c '= (or =M-x org-edit-special=). In order to
  add a new block, type =<s= press =<tab>= and add =emacs-lisp= as the block's
  language. Then You can edit the contents of the block as described above.

  For more information about source blocks, ou can consult the [[http://orgmode.org/manual/Working-with-source-code.html][relevant section]]
  in [[http://orgmode.org/manual/index.html][The Org Manual]].

  Using org-mode's tangle functionality fill generate ~init.el~ file. In order
  to avoid overwriting my customizations every time ~init.el~ is generated, I
  will relocate them to ~customizations.el~.

  #+begin_src emacs-lisp
    (setq custom-file "~/.emacs.d/customizations.el")
    ;; I don't want any customizations to linger. Anything interesting in this file
    ;; should be moved to the appropriate section in startup.
    ;; (load-file custom-file)
  #+end_src

** Disabling a code snippet

   When you want to disable a snippet, add ~:tangle no~ to the relevant source block.

   For example:

   #+begin_src common-lisp :tangle no
     ;;; This line will not be added to the generated configuration
   #+end_src


** Generating ~init.el~

   Execute =M-x org-babel-tangle=, or press =C-c C-v t= sequence to generate the
   startup files.

* Startup

** Add required libraries
   Some code snippets below require some packages. I am adding the most common ones here:

   #+begin_src emacs-lisp
     (require 'cl-lib)
   #+end_src
** Basic Setup
   There are a few important things here. We will

*** Prepare The Package Subsystem

     #+begin_src emacs-lisp
       (package-initialize)
       ;;; (setq package-enable-at-startup nil)
     #+end_src

*** Construct load path

     #+begin_src emacs-lisp
       (add-to-list 'load-path "~/.emacs.d/elisp/thirdparty")
       (add-to-list 'load-path "~/.emacs.d/elisp/mine")
     #+end_src

*** Set up my information before anything is loaded

     #+begin_src emacs-lisp
       (setq user-full-name "Vedat Hallac"
             user-mail-address "vedathallac@gmail.com")
     #+end_src

*** Set up backup strategy

    #+begin_src emacs-lisp
      (setq make-backup-files nil
            auto-save-default nil)
    #+end_src

** Utility functions

*** List Directory Contents Recursively

    #+begin_src emacs-lisp
      (defun recursive-directory-list (path)
        (let* ((toplevel (directory-files path t))
               (dirs '()))
          (while toplevel
            (let ((file (car toplevel)))
              (unless (member
                       (file-name-nondirectory file)
                       '("." ".." "cvs" "CVS" "rcs" "RCS" ".svn" "emacs" "xemacs" ".git"))
                (if (file-directory-p file)
                    (setq dirs (append dirs
                                       (recursive-directory-list file)))))
              (setq toplevel (cdr toplevel))))
          (setq dirs (append dirs (list path)))))
    #+end_src
** Packages

   Set up my favorite package sources. Usually [[https://melpa.org/][MELPA]] is enough on its own, but I
   like having a few more sources. If this is the first time emacs is started, I
   refresh the package contents.

   #+begin_src emacs-lisp
     (add-to-list 'package-archives '("melpa"  . "https://melpa.org/packages/") t)
     (add-to-list 'package-archives '("tromey" . "https://tromey.com/elpa/") t)
     (add-to-list 'package-archives '("gnu"    . "https://elpa.gnu.org/packages/") t)
     (add-to-list 'package-archives '("orgm"   . "https://orgmode.org/elpa/") t)
     (add-to-list 'package-archives '("copcu"  . "http://cop.cuyuz.biz/elpa/") t)
     (unless (> (length package-archive-contents) 0 )
       (package-refresh-contents))

   #+end_src

   All my package configuration is done using =use-package=. I will preinstall and configure this.

   #+begin_src emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-install 'use-package)
       (package-activate 'use-package))
     (require 'use-package)
     ;; (custom-set-variables '(use-package-verbose t)
     ;;                       '(use-package-always-ensure t))
   #+end_src

** Minimum versions of built-in packages

   I require minimum versions of certain packages. Sometime built-in package
   versions are not enough.

   The following portion installs packages when builtin version is not present,
   or not recent enough.

   #+begin_src emacs-lisp
     (defconst upgrade-builtins-min-versions '((tramp . (2 4))))

     (dolist (elt upgrade-builtins-min-versions)
       (let ((pkg (car elt))
             (min-ver (cdr elt)))
         (unless (package-installed-p pkg min-ver)
           (message "installing")
           (package-install (cadr (assoc pkg package-archive-contents))))))
   #+end_src

** Paths
   There are some paths required by different components. I will set those up in
   this section.

   #+begin_src emacs-lisp
     (custom-set-variables '(erc-dcc-get-default-directory "~/erc_dcc"))


   #+end_src
** Terminal Setup

   I usually have problems with terminals of various systems. It feels like
   every distribution generate slightly different key codes.

   I am not sure if what I do below is correct, but this one seems to work with
   all my Linux boxes.

   In addition, I load xterm, and initialize it to use 256 color, if possible.

   #+begin_src emacs-lisp
     (load "term/xterm")

     (defun terminal-init-screen ()
       "Terminal initialization function for screen."
        ;; Use the xterm color initialization code.
        (xterm-register-default-colors)
        (tty-set-up-initial-frame-faces))

     ;; Define sone terminal key codes.
     ;; TODO: How compatible are these between different terminals?
     (define-key function-key-map "\e[1;2A" '[S-up])
     (define-key function-key-map "\e[1;2B" '[S-down])
     (define-key function-key-map "\e[1;2C" '[S-right])
     (define-key function-key-map "\e[1;2D" '[S-left])
     (define-key function-key-map "\e[1;3A" '[M-up])
     (define-key function-key-map "\e[1;3B" '[M-down])
     (define-key function-key-map "\e[1;3C" '[M-right])
     (define-key function-key-map "\e[1;3D" '[M-left])
     (define-key function-key-map "\e[1;4A" '[M-S-up])
     (define-key function-key-map "\e[1;4B" '[M-S-down])
     (define-key function-key-map "\e[1;4C" '[M-S-right])
     (define-key function-key-map "\e[1;4D" '[M-S-left])
     (define-key function-key-map "\e[1;5A" '[C-up])
     (define-key function-key-map "\e[1;5B" '[C-down])
     (define-key function-key-map "\e[1;5C" '[C-right])
     (define-key function-key-map "\e[1;5D" '[C-left])
     (define-key function-key-map "\e[1;6A" '[C-S-up])
     (define-key function-key-map "\e[1;6B" '[C-S-down])
     (define-key function-key-map "\e[1;6C" '[C-S-right])
     (define-key function-key-map "\e[1;6D" '[C-S-left])
     (define-key function-key-map "\e[13~" '[F3])
     (define-key function-key-map "\e[14~" '[f4])
     ;; TODO: Fix these on a unix terminal. Or fix the ones above.
     (define-key key-translation-map (kbd "M-[ 1 ~") (kbd "<home>"))
     (define-key key-translation-map (kbd "M-[ 1 ^") (kbd "C-<home>"))
     (define-key key-translation-map (kbd "M-[ 1 ; 5 H") (kbd "C-<home>"))
     (define-key key-translation-map (kbd "<select>") (kbd "<end>"))
     (define-key key-translation-map (kbd "M-[ 4 ~") (kbd "<end>"))
     (define-key key-translation-map (kbd "M-[ 4 ^") (kbd "C-<end>"))
     (define-key key-translation-map (kbd "M-[ 1 ; 5 F") (kbd "C-<end>"))
   #+end_src
** Keyboard

   I define the misc shortcuts in this section.

   #+begin_src emacs-lisp
     (defun match-parenthesis (arg)
       "Match the current character according to the syntax table.

        Based on the freely available match-paren.el by Kayvan Sylvan.
        I merged code from goto-matching-paren-or-insert and match-it.

        You can define new \"parentheses\" (matching pairs).
        Example: angle brackets. Add the following to your .emacs file:

         (modify-syntax-entry ?< \"(>\" )
         (modify-syntax-entry ?> \")<\" )

        You can set hot keys to perform matching with one keystroke.
        Example: f6 and Control-C 6.

         (global-set-key \"\\C-c6\" 'match-parenthesis)
         (global-set-key [f6] 'match-parenthesis)

        Simon Hawkin <cema@cs.umd.edu> 03/14/1998"
       (interactive "p")
       ;;The ?= can be anything that is not a ?\(or ?\)
       (let ((syntax (char-syntax (or (char-after) ?=)))
             (syntax2 (char-syntax (or (char-before) ?=))))
         (cond
          ((= syntax ?\() (forward-sexp 1) (backward-char))
          ((= syntax ?\)) (forward-char) (backward-sexp 1))
          ((= syntax2 ?\() (backward-char) (forward-sexp 1) (backward-char))
          ((= syntax2 ?\)) (backward-sexp 1))
          (t (message "No match")))))

     (define-key global-map (kbd "M-]") 'match-parenthesis)
     (define-key global-map (kbd "<f5>") 'revert-buffer)

     (define-key global-map (kbd "C-x C-b") 'ibuffer)
   #+end_src
** Misc tweaks

   Tiny tweaks that don't seem to fit anywhere:

   - Reduce amount of typing when answering y/n questions;

     #+begin_src emacs-lisp
       (fset 'yes-or-no-p 'y-or-n-p)
     #+end_src

   - Avoid the startup screen:

     #+begin_src emacs-lisp
       (setq inhibit-startup-message t)
     #+end_src

   - Highlight matching parenthesis in all modes:

     #+begin_src emacs-lisp
       (show-paren-mode 1)
     #+end_src

   - Tidy up before save:
     #+begin_src emacs-lisp
       (add-hook 'before-save-hook
                 'delete-trailing-whitespace)
     #+end_src

   - Allow narrowing to region and page:
     #+begin_src emacs-lisp
       (put 'narrow-to-region 'disabled nil)
       (put 'narrow-to-page 'disabled nil)
     #+end_src

   - Editing environment:
     #+begin_src emacs-lisp
       (setq kill-do-not-save-duplicates t
             next-line-add-newlines nil
             require-final-newline t
             sentence-end-double-space nil
             tab-always-indent 'complete)

       ;; These become buffer local when set, so I use setq-default
       (setq-default tab-width 4
                     fill-column 80
                     indent-tabs-mode nil
                     case-fold-search nil)
     #+end_src

   - Enable syntax highlighting:
     #+begin_src emacs-lisp
       (global-font-lock-mode 1)
     #+end_src

   - Create new window for =display-buffer=:
     #+begin_src emacs-lisp
       (custom-set-variables '(pop-up-windows t))
     #+end_src

   - Generate unique buffer names:
     #+begin_src emacs-lisp
       (use-package uniquify
         :config
         (custom-set-variables '(uniquify-buffer-name-style 'post-forward)
                               '(uniquify-separator ":")))
     #+end_src
** Status Bar Setup

   Display line and column number in staus bar.

   #+begin_src emacs-lisp
     ;; There are no scrollbars. I want to see location.
     (setq line-number-mode t
           column-number-mode t)
   #+end_src

** L10N & I18N

   #+begin_src emacs-lisp
     (set-language-environment 'utf-8)
   #+end_src

   I used to use use my weird input method for Turkish character input. Now I rely on xkb, so ~:tangle no~.
   #+begin_src emacs-lisp :tangle no
     (require 'turkish-doubles)
     (set-language-environment "Turkish")
   #+end_src

* Appearance

  I will set up how my emacs looks in GUI mode. There is some level of terminal
  mode setup, but it is fairly limited.

** GUI components
   #+begin_src emacs-lisp
     (add-hook 'after-make-frame-functions (lambda (frame)
                                             (when (window-system frame)
                                               (scroll-bar-mode -1)
                                               ;; (set-cursor-color "light green")
                                               )
                                             (blink-cursor-mode -1)
                                             (setq transient-mark-mode nil)
                                             (menu-bar-mode -1)
                                             (tool-bar-mode -1)))

     ;; Make sure the hooks are run if we are not in daemon mode
     ;; NOTE: Check if this is still necessary.
     (if (not (daemonp))
         (add-hook 'after-init-hook (lambda ()
                                      (run-hook-with-args 'after-make-frame-functions
                                                          (selected-frame)))))
   #+end_src

** Custom faces
   I need some additional face definitions for certain modes.

   #+begin_src emacs-lisp
     (defface large-variable-pitch '((t (:inherit 'variable-pitch :height 95)))
       "Font for less eye strain during prolonged reading"
       :group 'local)
   #+end_src

** Variable pitch mode setup

   This is a helper function to switch to variable pitch mode. Use this as:
   #+begin_src emacs-lisp :tangle no
     (use-package some-package
       :hook ((some-package-mode . set-buffer-variable-pitch)))
   #+end_src

   You can pass a list of face definitions in mode that should still be left as fixed pitch.

   #+begin_src emacs-lisp
     (defun set-buffer-variable-pitch (&rest fixed-pitch-faces)
       (variable-pitch-mode t)
       (setq line-spacing 3)
       (when fixed-pitch-faces
         (mapcar (lambda (x) (set-face-attribute x nil :inherit 'fixed-pitch)) fixed-pitch-faces)))
   #+end_src
* Keyboard Shortcuts
  The key bindings below are for visiting URLs locally and globally in various shr-derived modes.

  #+begin_src emacs-lisp
    (defun eww-browse-external ()
      (interactive)
      (shr-browse-url t))

    (defun eww-browse-shr-url ()
      (interactive)
      (eww (get-text-property (point) 'shr-url)))

    (defun vh/eww-toggle-size ()
      "Use large fonts in shr buffer"
      (interactive)
      (if (eq shr-current-font 'large-variable-pitch)
          (setq shr-current-font 'variable-pitch)
        (make-local-variable 'shr-current-font)
        (setq shr-current-font 'large-variable-pitch))
      (eww-reload t))

    (use-package eww
      :bind (:map eww-mode-map
                  (", f" . vh/eww-toggle-size)
             :map eww-link-keymap
             ("V" . eww-browse-external)))

    (use-package shr
      :bind (:map shr-map
                  ("v" . eww-browse-shr-url)
                  ("V" . eww-browse-external)))

    (use-package elfeed
      :ensure t
      :bind (:map elfeed-show-mode-map
                  ("v" . eww-browse-shr-url)
                  ("V" . eww-browse-external)))

    (use-package w3m
      :ensure t
      :bind (:map w3m-link-map
                  ("v" . (lambda () (interactive) (eww (w3m-anchor (point)))))
                  ("V" . (lambda () (interactive) (w3m-view-url-with-browse-url (w3m-anchor (point)))))))
  #+end_src
* GPG setup

** Agent connection

   When running as daemon, the environment variables reflect the daemon
   environment. We need to refresh them according to the client that we start.

   #+begin_src emacs-lisp
     (defun wg/kludge-gpg-agent ()
       (if (display-graphic-p)
           (setenv "DISPLAY" (terminal-name))
         (setenv "GPG_TTY" (terminal-name))))

     (add-hook 'window-configuration-change-hook 'wg/kludge-gpg-agent)
   #+end_src
* Tramp
  Allow remote ~.profile~ file to update tramp's ~PATH~ environment variable.

  Also make use of control sockets to speed up operations.

  I will pick up the version from ~gnu~ elpa archive, and configure session
  timeouts. I am not comfortable with leaving my sudo sessions lying around.

  #+begin_src emacs-lisp
    (defun vh/tramp-add-or-change-param (method param)
      (let ((elt (assoc method tramp-methods)))
        (when elt
          (let ((filtered-params (delq nil
                                       (mapcar (lambda (e) (when (not (eq (car e) (car param))) e))
                                               (cdr elt)))))
            (setcdr elt (push param filtered-params))))))

    (use-package tramp
      :ensure t
      :config
      (vh/tramp-add-or-change-param "sudo" '(tramp-session-timeout 600))
      (vh/tramp-add-or-change-param "ssh" `(tramp-session-timeout ,(* 5 60 60))))
  #+end_src

  #+begin_src emacs-lisp
    (use-package tramp-sh
      :config
      (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
      (customize-set-variable 'tramp-ssh-controlmaster-options
       (concat
        "-o ControlPath=/tmp/ssh-ControlPath-%%r@%%h:%%p "
        "-o ControlMaster=auto -o ControlPersist=15m"))

      (customize-set-variable 'tramp-use-ssh-controlmaster-options t)

      (customize-set-variable
       'tramp-completion-reread-directory-timeout nil)

      (defun cd-disable-projectile-mode-for-remote (current-dir)
        (if (and (functionp 'projectile-mode) (file-remote-p current-dir))
            (projectile-mode 0)
          (projectile-mode 1)))
      (advice-add 'cd :filter-return #'cd-disable-projectile-mode-for-remote))
  #+end_src

* Misc Functions

** Eshell

   #+begin_src emacs-lisp
     (use-package eshell
       :bind ("C-c s" . eshell)
       :config
       (custom-set-variables '(eshell-scroll-to-bottom-on-input 'all)
                             '(eshell-error-if-no-glob t)
                             '(eshell-hist-ignoredups t)
                             '(eshell-save-history-on-exit t)
                             ;; Not sure about this (eshell-prefer-lisp-functions nil)
                             '(eshell-destroy-buffer-when-process-dies t))
       (setenv "PAGER" "cat")
       (defvar zakame/ansi-escapes-re
         (rx (or ?\233 (and ?\e ?\[))
             (zero-or-more (char (?0 . ?\?)))
             (zero-or-more (char ?\s ?- ?\/))
             (char (?@ .?~))))
       (defun zakame/nuke-ansi-escapes (beg end)
         (save-excursion
           (goto-char beg)
           (while (re-search-forward zakame/ansi-escapes-re end t)
             (replace-match ""))))
       (defun zakame/eshell-nuke-ansi-escapes ()
         (zakame/nuke-ansi-escapes eshell-last-output-start eshell-last-output-end))
       (add-hook 'eshell-mode-hook
                 (lambda ()
                   (add-to-list 'eshell-output-filter-functions
                                'zakame/eshell-nuke-ansi-escapes t))
                 ))
   #+end_src

** Shell
   #+begin_src emacs-lisp
     (use-package shell
       :bind ("C-c S" . shell))
   #+end_src
* Overlays to text
  Sometimes I want to copy the output of my org column view. The script below
  will allow you to turn the overlays into plain text, allowing you to save or
  copy it as you want.

  #+begin_src emacs-lisp
    (defun overlays-to-text ()
      "Create a new buffer called *text* containing the visible text
    of the current buffer, ie. it converts overlays containing text
    into real text."
      (interactive)
      (let ((tb (get-buffer-create "*text*"))
            (s (point-min))
            (os (overlays-in (point-min) (point-max))))
        (with-current-buffer tb
          (erase-buffer))
        (setq os (sort os (lambda (o1 o2)
                            (< (overlay-start o1)
                               (overlay-start o2)))))
        (mapc (lambda (o)
                (let ((bt (buffer-substring-no-properties s (overlay-start o)))
                      (b (overlay-get o 'before-string))
                      (text (or (overlay-get o 'display)
                                (buffer-substring-no-properties (overlay-start o) (overlay-end o))))
                      (a (overlay-get o 'after-string))
                      (inv (overlay-get o 'invisible)))
                  (with-current-buffer tb
                    (insert bt)
                    (unless inv
                      (when b (insert b))
                      (insert text)
                      (when a (insert a))))
                  (setq s (overlay-end o))))
              os)
        (let ((x (buffer-substring-no-properties s (point-max))))
          (with-current-buffer tb
            (insert x)))
        (pop-to-buffer tb)))
  #+end_src
* Packages

** Spellchecking
   #+begin_src emacs-lisp
     (use-package wucuo :ensure t)
   #+end_src
** Buffers

*** Auto close buffers
    I like to keep open buffers to a minimum. Midnight mode allows me to
    automatically close buffers after a timout period.

    #+begin_src emacs-lisp
      (use-package midnight
        :config
        ;; run clean-buffer-list every 2 hours
        (defvar clean-buffer-list-timer (run-at-time t 7200 'clean-buffer-list)
          "Stores clean-buffer-list timer if there is one.

           You can disable clean-buffer-list by (cancel-timer clean-buffer-list-timer).")
             ;; kill buffers if they were last disabled more than 15 minutes ago
             (custom-set-variables '(clean-buffer-list-delay-special 900)
                                   ;; kill everything, clean-buffer-list is very intelligent at not killing
                                   ;; unsaved buffer.
                                   '(clean-buffer-list-kill-regexps '("^.*$"))

                                   ;; keep these buffers untouched
                                   '(clean-buffer-list-kill-never-buffer-names '("*Messages*" "*cmd*" "*scratch*"
                                                                                 "*w3m*" "*w3m-cache*"
                                                                                 "*Group*" "*eshell*"))
                                   '(clean-buffer-list-kill-never-regexps '("^\\*EMMS Playlist\\*.*$"
                                                                            "^\\*Article "
                                                                            "^\\*Summary "
                                                                            ".*\\.org"))))
    #+end_src

** Text Editing
*** Undo
    I like the control undo-tree povides.

    #+begin_src emacs-lisp
      (use-package undo-tree
        :ensure t
        :init
        (global-undo-tree-mode))
    #+end_src
*** Marking
    #+begin_src emacs-lisp
      (use-package expand-region
        :after hydra
        :ensure t
        :bind (("C-c v" . hydra-expand-region/body))
        :init
        (defhydra hydra-expand-region (:pre (activate-mark)
                                            :color red)
          "Expand Region"
          ("v" (er/expand-region 1) "Expand")
          ("V" er/contract-region "Contract")
          ("l" vh/expand-region-to-lines)
          ("C-v" (er/expand-region 0) "Reset" :color blue)
          ("s" (mark-sexp) "Sexp")
          ("t" er/mark-nxml-tag "Tag")
          ("e" er/mark-nxml-element "Element")))
    #+end_src

    Here's a little something to mark whole lines:
    #+begin_src emacs-lisp
      (defun vh/expand-region-to-lines ()
          (interactive)
        (when (eq (point) (region-beginning))
          (exchange-point-and-mark))
        (let ((end (+ 1 (point-at-eol))))
          (exchange-point-and-mark)
          (let ((start (point-at-bol)))
            (push-mark end)
            (exchange-point-and-mark)
            (push-mark start))))

      (bind-key "C-c C-v" #'vh/expand-region-to-lines)
    #+end_src
*** Key bindings
**** Hydra

     Hydra is a key binding mechanism that allows menus to be displayed after
     initial key, and different operations to become repeatable. It doesn't do a
     lot that normal key binding doesn't do, but provides quite a bit of
     convenience.

     #+begin_src emacs-lisp
       (use-package hydra
         :ensure t)
     #+end_src
** Dired
   Not a lot of customizations here... yet.
   #+begin_src emacs-lisp
     (put 'dired-find-alternate-file 'disabled nil)
   #+end_src

** Compile

   #+begin_src emacs-lisp
     (custom-set-variables '(compilation-scroll-output t))
   #+end_src
** escreen [Disabled - using elscreen now]

   This is one of my favorites: emacs window session manager. It provides
   something similar to a window manager virtual desktops.

   #+begin_src emacs-lisp :noweb yes :tangle no
     (use-package escreen
       :disabled
       :demand
       :bind (:map escreen-map
                   ("l"  . escreen-display-screens)
                   ("\\" . toggle-input-method))

       :config
       <<vh-escreen>>
       (escreen-install)
       (add-hook 'escreen-goto-screen-hook #'escreen-display-screens))
   #+end_src

   And some helper files

   #+name: vh-escreen
   #+begin_src emacs-lisp :tangle no
     (defun vh-find-escreen-data-by-number (number)
       (car (delq nil
                  (mapcar (lambda (x) (and (= (car x) number) x))
                          (escreen-configuration-alist)))))

     (defun vh-escreen-buffer-name (number)
       "Extract the buffer name for the given screen number"
       (let* ((screen-data (vh-find-escreen-data-by-number number))
              (data-map (escreen-configuration-data-map screen-data)))
         (escreen-configuration-data-map-critical-buffer-name
          (escreen-configuration-data-map-critical (car data-map)))))


     (defun escreen-display-screens ()
       "Display list of defined screens with an emphasis on the active one."
       (interactive)
       (let ((escreens (escreen-get-active-screen-numbers))
             (screen-msg ""))

         (dolist (s escreens)
           (setq screen-msg
                 (concat screen-msg
                         (let ((display-str (concat (number-to-string s) ":" (vh-escreen-buffer-name s))))
                           (if (= (escreen-current-screen-number) s)
                               (propertize display-str 'face 'bold-italic)
                             display-str))
                         " ")))
         (message "escreen: %s" screen-msg)))
   #+end_src
** elscreen [Disabled
   Emacs window session manager - sort of a pager for emacs

   #+begin_src emacs-lisp :noweb yes :tangle no
     (use-package elscreen
       :ensure t
       :demand
       :config
       (elscreen-start)
       (custom-set-variables '(elscreen-display-tab nil)))
   #+end_src
** eyebrowse

   Emacs session manager. I use this for virtual "desktops" or window configurations.

   I am disabling for now. It looks like using multiple frames is good enough for me.

   #+begin_src emacs-lisp :noweb yes :tangle no
     (use-package eyebrowse
       :ensure t
       :demand
       :init
       (eyebrowse-mode)
       :config
       (custom-set-variables '(eyebrowse-keymap-prefix (kbd "C-z"))))
   #+end_src
** browse-kill-ring

   Displays the contents of the kill ring, and allows you to select an
   arbitrary entry from the kill ring instead of walking through the key ring
   via the usual =C-y=, followed by =M-y= sequence.

   Press =M-y= any time to get a visual list of the kill ring contents.
   Navigate using cursor up/down, select by pressing =<Enter>= and abort by
   pressing =q=.

   #+begin_src emacs-lisp
     (use-package browse-kill-ring
       :ensure t
       :config (browse-kill-ring-default-keybindings))
   #+end_src

** paredit

   Get your parenthesis under control. Visit [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][the animated guide to paredit]] for
   a visual explanation of the mode.

   #+begin_src emacs-lisp
     (use-package paredit
       :ensure t
       :init
       (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
       (add-hook 'lisp-mode-hook #'enable-paredit-mode)
       (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode))
   #+end_src

** ace-window

   Easy travel between windows.

   #+begin_src emacs-lisp
     (use-package ace-window
       :ensure t
       :bind (( "C-x o" . ace-window))
       :config
       (custom-set-variables '(aw-scope 'visible)))
   #+end_src

** avy

   Jump around in the buffer quickly.

   #+begin_src emacs-lisp
     (use-package avy
       :ensure t
       :bind (("M-g j" . avy-goto-char-timer)
              ("C-c y l" . avy-copy-line)
              ("C-c y r" . avy-copy-region)
              ("C-c k l" . avy-kill-whole-line)
              ("C-c k r" . avy-kill-region)
              ("C-c K l" . avy-kill-ring-save-whole-line)
              ("C-c K r" . avy-kill-ring-save-region)))

   #+end_src

** ace-jump-buffer

   Jump between buffers using the avy quick select method. Function lists
   buffers, and allows you to select one using the buffer's assigned letter.

   #+begin_src emacs-lisp
     (use-package ace-jump-buffer
       :ensure t
       :bind (("C-c b b"   . ace-jump-buffer)
              ("C-c b 4 b" . ace-jump-buffer-other-window)
              ("C-c b p"   . ace-jump-projectile-buffers)))
   #+end_src
** Transparent encryption

   /EasyPG/ is a library to interface with /gpg/. It can be configured to
   transparently decrypt files ending with =.gpg= extension.

   #+begin_src emacs-lisp
     (use-package epg
       :ensure t
       :config
       (let ((gpg-prg "/usr/bin/gpg2"))
         (when (file-executable-p gpg-prg)
           (custom-set-variables `(epg-gpg-program ,gpg-prg)))))

     (use-package auth-source
       :after epg
       :config
       (when  epg-gpg-program
         (add-to-list 'auth-sources
                      '(:source "~/.emacs.d/.secrets/authinfo.gpg" :host t :protocol t))))
   #+end_src
** Dired

   #+begin_src emacs-lisp
     (use-package dired
       :defer
       :config
       (custom-set-variables '(dired-dwim-target t))
       (add-hook 'dired-mode-hook
                 (lambda ()
                   (make-local-variable 'coding-system-for-read)
                   (setq coding-system-for-read 'utf-8))))
   #+end_src
** ERC
   IRC is still alive. :)

   #+begin_src emacs-lisp
     (use-package erc
       :commands erc
       :config
       (custom-set-variables '(erc-dcc-get-default-directory "~/erc_dcc")
                             '(erc-dcc-mode t)
                             '(erc-dcc-verbose t)
                             '(erc-modules '(autojoin button completion dcc fill irccontrols list match menu move-to-prompt netsplit networks noncommands readonly ring stamp track)))

       ;; If the DCC download directory is missing, create it.
       (if (not (file-exists-p erc-dcc-get-default-directory))
           (make-directory erc-dcc-get-default-directory t)))
   #+end_src
** Mini buffer input and completion

*** Ivy and friends
    Abo abo has created a really useful module for completing input that
    strikes a good balance between size and functionality.

    #+begin_src emacs-lisp
      (use-package ivy
        :ensure t
        :pin melpa
        :demand
        :config
        (ivy-mode)
        (custom-set-variables '(ivy-use-virtual-buffers t)
                              '(ivy-count-format "(%d/%d) "))
        (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))

      (use-package ivy-hydra
        :requires ivy
        :ensure t)

      (use-package swiper
        :ensure t
        :requires ivy
        :bind ("C-s" . swiper)
        :config
        ;; This is an emacs25.x feature - for folding characters into native ASCII
        (setq search-default-mode nil)
        (ivy-set-occur 'swiper 'swiper-occur))

      (use-package counsel
        :ensure t
        :bind (("M-g h" . counsel-org-agenda-headlines)
               ("M-g i" . counsel-imenu))
        :config
        ;; Assume utf-8 output from my counsel commands
        (defun vh/coding-system--counsel-cmd (&optional old-function &rest args)
          (let ((coding-system-for-read 'utf-8-unix))
            (apply old-function args)))

        ;; Patch counsel-ag only for now. Will extend as more problems show up
        (advice-add #'counsel-ag :around #'vh/coding-system--counsel-cmd))
    #+end_src
*** DISABLED IDO mode

    My first minibuffer helper. I am using ivy these days.

    #+begin_src emacs-lisp
      (use-package ido-vertical-mode
        :disabled)

      (use-package flx-ido
        :disabled)

      (use-package ido
        :disabled
        :config
        (ido-vertical-mode)
        (flx-ido-mode))
    #+end_src
*** DISABLED Helm

    For a short period, I've switched from /ido/ to /helm/. /Ivy/ is better for me.

    #+begin_src emacs-lisp
      (use-package helm
        :disabled
        :bind ( ("C-x C-f" . helm-find-files)
                ("C-x b" . helm-buffers-list)
                ("M-x"  . helm-M-x)))
    #+end_src
** Multiple Cursors
   #+begin_src emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind ( ("C-c m l" . mc/edit-lines)
               ("C-c m m" . mc/mark-more-like-this-extended)
               ("C-c m p" . mc/mark-previous-word-like-this)
               ("C-c m n" . mc/mark-next-word-like-this)
               ("C-c m P" . mc/mark-previous-symbol-like-this)
               ("C-c m N" . mc/mark-next-symbol-like-this)
               ("C-c m i" . mc/insert-numbers)
               ("C-c m s" . mc/mark-all-symbols-like-this-in-defun)
               ("C-c m S" . mc/mark-all-symbols-like-this)
               ("C-c m w" . mc/mark-all-symbols-like-this-in-defun)))

     ;; I sometimes use this, too
     (use-package iedit
       :ensure t)
   #+end_src
** Magit
   #+begin_src emacs-lisp
     (use-package magit
       :ensure t
       :bind (("C-c g" . magit-status))
       :init
       (use-package git-commit
         :ensure t))
   #+end_src
** TODO Auto complete

   I need to work on this, and maybe enable it globally.

   #+begin_src emacs-lisp
     (use-package auto-complete
       :ensure t
       :config
       (setq-default ac-sources (push 'ac-source-yasnippet ac-sources)))
   #+end_src
** TODO Yasnippet
   #+begin_src emacs-lisp
     (use-package yasnippet
       :ensure t
       :commands (yas-minor-mode yas-global-mode yas-reload-all))
   #+end_src
** Which-key
   Show keyboard shotrtcuts following the keys already pressed.

   #+begin_src emacs-lisp
     (use-package which-key
       :ensure t
       :config
       (which-key-mode))
   #+end_src
** E-mail
*** Reading: GNUS

    For variable pitch, find the hook and use ~(set-buffer-variable-pitch 'gnus-header-name 'gnus-header-subject 'gnus-header-content 'gnus-header-from)~.

    #+begin_src emacs-lisp :noweb yes
      (use-package gnus
        :commands gnus
        :config
        <<gnus-config-support>>
        (custom-set-variables '(gnus-select-method '(nntp "news.easynews.com"))
                              '(gnus-posting-styles '(((message-news-p)
                                                       (name "Vedat Hallac")
                                                       (address "vedat.hallac@mail.invalid"))
                                                      ("gmail-2"
                                                       (name "Dys@Bloodfeather")
                                                       (address "dys.wowace@gmail.com"))
                                                      ("gmail-android"
                                                       (name "Vedat Hallac")
                                                       (address "vedat@android.ciyiz.biz"))
                                                      ("gmail-pia"
                                                       (name "Vedat Hallaç")
                                                       (address "vedat.hallac@pia-team.com"))
                                                      ("ms-piasys"
                                                       (name "Vedat Hallaç")
                                                       (address "vedat.hallac@pia-systems.com"))))
                              `(gnus-secondary-select-methods '(,(mk-gnus-select-method "gmail-1" "imap.gmail.com")
                                                               ,(mk-gnus-select-method "gmail-2" "imap.gmail.com")
                                                               ,(mk-gnus-select-method "gmail-android" "imap.gmail.com")
                                                               ,(mk-gnus-select-method "gmail-pia" "imap.gmail.com")))
                              '(gnus-use-adaptive-scoring '(word line))
                              '(gnus-score-expiry-days 60)
                              '(gnus-default-adaptive-score-alist '((gnus-unread-mark)
                                                                    (gnus-ticked-mark (from 40))
                                                                    (gnus-dormant-mark (from 50))
                                                                    (gnus-saved-mark (from 200) (subject 50))
                                                                    (gnus-del-mark (from -20) (subject -50))
                                                                    (gnus-read-mark (from 20) (subject 10))
                                                                    (gnus-killed-mark (from -10) (subject -30)))))
        (setq gnus-topic-line-format "%i[ %0{%(%n (new: %A)%)%} ]\n"
              mail-self-blind t                     ; Add me to Bcc:
              mail-user-agent 'gnus-user-agent      ; Allow Gcc:

              ;; Work-around for GMail's internal folders: When the IMAP folder contains
              ;; characters [ and ] (actually any regexp character), the function
              ;; `gnus-score-find-bnews' cannot return the ADAPT file name. This causes ADAPT
              ;; files to be generated, but not used in these groups.
              ;; The following setting ensures these two characters are never used in ADAPT
              ;; file names.
              nnheader-file-name-translation-alist '((?[ . ?_) (?] . ?_))
              ;; see bbdb-mua-summary-unify-format-letter configuration for bbdb for uB
              gnus-summary-line-format "%U%R%z%I%(%[%4L: %-23,23uB%]%) %s\n"
              )

        (when (require 'bbdb nil t)
          (bbdb-initialize 'gnus)
          (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus))

        (add-hook 'gnus-group-mode-hook 'gnus-topic-mode))

      (use-package mm-decode
        :defer
        :config
        (custom-set-variables '(mm-text-html-renderer 'w3m)
                              '(mm-inline-text-html-with-images t)
                              '(mm-w3m-safe-url-regexp nil)
                              '(mm-inline-large-images t)
                              '(mm-coding-system-priorities '(utf-8))))
    #+end_src
**** Configuration support functions
     #+name: gnus-config-support
     #+begin_src emacs-lisp :tangle no
       (defun mk-gnus-select-method (alias addr &optional port ignore-regexp)
         "Construct an entry for `gnus-secondary-select-methods' variable.

       ALIAS is the server alias. ADDR and PORT specify the server to
       connect to. The optional variable IGNORE_REGEXP is copied to
       gnus-ignored-newsgroups. It defaults to \"^to\\.\\|^[0-9. 	]+\\( \\|$\\)\\|^[\”]\”[#’()]\""
         `(nnimap ,alias
                  (nnimap-address ,addr)
                  (nnimap-server-port ,(or port 993))
                  (nnimap-stream tls)
                  (nnimap-list-pattern ("INBOX" "*"))
                  (nnimap-expunge-on-close always)
                  (gnus-check-new-newsgroups nil)
                  (gnus-ignored-newsgroups ,(or ignore-regexp
                                                "^to\\.\\|^[0-9. 	]+\\( \\|$\\)\\|^[\”]\”[#’()]"))))
     #+end_src
*** Reading: notmuch

    Apply the first tag to all mesages in notmuch-show view:
    - Get all tags using ~(let ((x nil)) (notmuch-show-mapc (lamb:da () (push (notmuch-show-get-tags) x))) x)~ or some such
    - Get the union using ~(let ((t nil)) (mapcan lambda (x) x aweek-list) t)~.
    - Calculate tag differences. Not sure how. There may be a function. If not, use variation of the above. Then apply tag delta. find function.

    #+begin_src emacs-lisp
      (defun vh/notmuch-show-delete-thread ()
        (interactive "")
        (let ((notmuch-archive-tags '("-inbox" "+deleted")))
          (notmuch-show-archive-thread-then-exit)))

      (defun vh/notmuch-address-selection-function (prompt collection initial-input)
        (let* ((from (or  (message-fetch-field "From" "")))
               (mail-addr (car
                           (delq nil (mapcar
                                      (lambda (x) (when  (string-match "@" x) x))
                                      (split-string from "[<>]")))))
               (domain (when mail-addr
                         (cadr (split-string mail-addr "@"))))
               (exists (and (delq nil (mapcar
                                       (lambda (x)  (string-match domain x))
                                       collection))
                            t)))
          ;; I am doing something nasty - orig is the string we search for
          (notmuch-address-selection-function prompt collection
                                              (or
                                               (and exists domain)
                                               orig))))

      (use-package notmuch
        :ensure t
        :commands (vh/notmuch-show-delete-thread notmuch-mua-new-mail)
        :bind (("C-c n" . vh/hydra-notmuch-global/body)
               :map notmuch-show-mode-map
               ("K" . vh/notmuch-show-delete-thread))
        :after hydra
        :init
        (defhydra vh/hydra-notmuch-global (:color blue)
          "Notmuch menu"
          ("n" (notmuch) "Landing Page")
          ("m" (notmuch-mua-new-mail) "Compose mail")
          ("s" (notmuch-search) "Search mail")
          ("z" (notmuch-tree) "Search Mail (tree view)")
          ("j" (notmuch-jump-search) "Search with saved queries "))
        (custom-set-variables '(notmuch-saved-searches
                                (quote
                                 ((:name "inbox.personal" :query "tag:inbox and tag:personal" :key "im")
                                  (:name "inbox.work" :query "tag:inbox and tag:pia" :key "ip")
                                  (:name "unread.personal" :query "tag:unread and tag:personal" :key "um")
                                  (:name "unread.work.pia" :query "tag:unread and tag:pia" :key "up")
                                  (:name "unread.work.qbit" :query "tag:unread and tag:qbit" :key "uq")
                                  (:name "unread.work.wamo" :query "tag:unread and tag:wamo" :key "uw")
                                  (:name "flagged" :query "tag:flagged" :key "f")
                                  (:name "flagged-tree" :search-type tree :query "tag:flagged" :key "F")
                                  (:name "sent" :query "tag:sent" :key "t")
                                  (:name "drafts" :query "tag:draft" :key "dr")
                                  (:name "today" :query "dag:unread and date:today" :key "dt")
                                  (:name "last week" :query "date:\"this week\"" :key "dw")
                                  (:name "last week" :query "date:\"this month\"" :key "dm")
                                  (:name "all mail" :query "*" :key "a")
                                  (:name "info" :query "tag:info" "i")
                                  (:name "recent" :query "tag:unread and (date:yesterday or date:today)" :key "ur" :search-type tree)))))
        :config
        ;; allow linking to mail from org-mode files
        (require 'ol-notmuch)
        (setq notmuch-command (expand-file-name "~/bin/remote-notmuch.sh"))
        (custom-set-variables
         '(notmuch-archive-tags '("-inbox" "+archived"))
         '(notmuch-always-prompt-for-sender t)
         '(notmuch-identities (quote
                               ("Vedat Hallaç <vedat.hallac@pia-team.com>"
                                "Vedat Hallaç <vedath@7island.com>"
                                "Vedat Hallaç <vedat@hallac.net>"
                                "Vedat Hallaç <vedat.hallac@pia-systems.com>"
                                "Vedat Hallaç <vedat@wamo.io>")))
         '(mm-text-html-renderer 'w3m))
        ;; Mark deleted messages unread for fast delete
        (setcar (cdr (assoc "d" notmuch-tagging-keys)) '("+deleted" "-inbox" "-unread"))
        (push '("lf" ("+financial" "-inbox") "Financial") notmuch-tagging-keys)
        (push '("lp" ("+project" "-inbox") "Project") notmuch-tagging-keys)
        (push '("lP" ("+prospect" "-inbox") "Project") notmuch-tagging-keys)
        (push '("li" ("+info" "-inbox") "info") notmuch-tagging-keys)
        (push '("lnn" ("+notice" "-inbox") "Notice") notmuch-tagging-keys)
        (push '("lnm" ("+misc" "-inbox") "Misc") notmuch-tagging-keys)
        (push '("lnN" ("+announcement" "-inbox") "Announcement") notmuch-tagging-keys)
        (push '("lns" ("+siam" "-inbox") "SIAM") notmuch-tagging-keys)
        (push '("lna" ("+acm" "-inbox") "SIAM") notmuch-tagging-keys)
        (push '("lnb" ("+boun" "-inbox") "Boğ. Üni.") notmuch-tagging-keys)

        (setq notmuch-address-selection-function #'vh/notmuch-address-selection-function))
    #+end_src
*** Composing messages

    #+begin_src emacs-lisp :noweb yes
      (use-package message
        :bind (:map message-mode-map
                    ("C-c o" . vh/message-edit-body-as-org)
                    ("C-c h" . vh/message-org-to-html)
                    ("C-c s" . vh/insert-pia-html-sig))
        :defer
        :config
        (custom-set-variables '(message-alternative-emails (regexp-opt '("vedathallac@gmail.com"
                                                                         "vedat.hallac@gmail.com"
                                                                         "dys.wowace@gmail.com"
                                                                         "vedat@android.ciyiz.biz"
                                                                         "vedat@oyun.cuyuz.biz"
                                                                         "vedathallac@yandex.com"
                                                                         "vedat@hallac.net"
                                                                         "vedath@7island.com"
                                                                         "vedat.hallac@pia-team.com"
                                                                         "vedat.hallac@pia-systems.com"
                                                                         "vedat@wamo.io")))
                              '(send-mail-function 'smtpmail-send-it))

        <<mail-compose-functions>>

        (require 'smtpmail)
        (when (require 'bbdb nil t)
          (bbdb-initialize 'message)
          (bbdb-insinuate-message)

          (setq bbdb-mua-pop-up nil
                bbdb-complete-mail-allow-cycling t)))
    #+end_src
**** HTML Mail support
     :PROPERTIES:
     :header-args: :tangle no
     :END:

     The functions below allow me to edit mail body as an org file and export
     the org body to an HTML mime attachment.

     #+name: mail-compose-functions
     #+begin_src emacs-lisp
       (defun vh/message-edit-body-as-org ()
         "Edit the body of the message in org-mode.

       When I need to send an e-mail in HTML mode, I can easily edit in org-mode, then export using vh/message-org-to-html"
         (interactive)
         (let ((old-mode major-mode)
               (body-start (save-excursion
                             (message-goto-body)
                             (point))))
           (narrow-to-region body-start (point-max))
           ;; (setq vh-message-last-mode major-mode)
           (org-mode)
           (set (make-local-variable 'vh/message-last-mode) old-mode))
         (add-hook 'org-ctrl-c-ctrl-c-final-hook 'vh/message-back-to-message))

       (defun vh/message-back-to-message ()
         "You don't need to call this usually. Just hitting 'C-c C-c' should take you out"
         (interactive)
         (when (and (boundp 'vh/message-last-mode)
                    vh/message-last-mode)
           (widen)
           (funcall vh/message-last-mode)
           (setq vh/message-last-mode nil)
           (remove-hook 'org-ctrl-c-ctrl-c-final-hook 'vh/message-back-to-message)
           t))

       (defun vh/message-org-to-html (arg)
         (interactive "P")
         (message-goto-body)
         (save-restriction
           (narrow-to-region (point) (point-max))
           (let* ((org-html-postamble (if arg nil
                                        vh/pia-html-sig))
                  (text (org-export-as 'html)))
             (kill-region (point-min) (point-max))
             (mml-generate-mime "related")
             (mml-insert-multipart "alternative")
             (mml-insert-part "text/plain")
             (yank)
             (mml-insert-part "text/html")
             (insert (concat text "\n")))))
     #+end_src

     This function allows me to insert my PiA signature to HTML mails.

     #+name: mail-compose-functions
     #+begin_src emacs-lisp
              (defconst vh/pia-html-sig
                (base64-decode-string
                  ;; Abusing base64 to avoid escaping the quotes.
                  (concat "PGRpdiBzdHlsZT0icGFkZGluZy10b3A6N3B4O2ZvbnQtZmFtaWx5OidWZXJkYW5hJywnc2Fucy1z"
                          "ZXJpZic7Zm9udC1zaXplOjhwdCI+PGEgaHJlZj0iaHR0cDovL3d3dy5waWEtdGVhbS5jb20vIiB0"
                          "YXJnZXQ9Il9ibGFuayI+PGltZyBzcmM9Imh0dHA6Ly93d3cucGlhLXRlYW0uY29tL2ltYWdlcy9s"
                          "b2dvLWJsYWNrLnBuZyIgaGVpZ2h0PSI3MiIgd2lkdGg9IjE2MCIvPjwvYT48aHIgd2lkdGg9IjE2"
                          "MCIgYWxpZ249ImxlZnQiLz48cCBhbGlnbj0ibGVmdCI+PHNwYW4gc3R5bGU9ImZvbnQtc2l6ZTo5"
                          "cHQiIGxhbmc9IkVOLVVTIj48Yj5BaG1ldCBWZWRhdCBIYWxsYSYjMjMxOzwvYj48L3NwYW4+PGJy"
                          "Lz5IZWFkIG9mIERldmVsb3BtZW50IERlcGFydG1lbnQ8YnIvPjxici8+TTogKzkwIDU0MSA4MzMg"
                          "MjggODI8YnIvPjxzcGFuIHN0eWxlPSJjb2xvcjojMDA2OGNmOyI+PGEgaHJlZj0ibWFpbHRvOnZl"
                          "ZGF0LmhhbGxhY0BwaWEtdGVhbS5jb20iPjx1PnZlZGF0LmhhbGxhY0BwaWEtdGVhbS5jb208L3U+"
                          "PC9hPjwvc3Bhbj48YnIvPjxiPlRla25vcGFyayAmIzMwNDtzdGFuYnVsIFNhbmF5aSBNYWguPC9i"
                          "Pjxici8+VGVrbm9wYXJrIEJ1bHZhciYjMzA1OyAxLzFDIDE2MDEtMTYwMjxici8+MzQ5MDYgS3Vy"
                          "dGsmIzI0Njt5IC8gJiMzMDQ7c3RhbmJ1bDxici8+VGVsL0ZheDogKzkwIDIxNiAyOTAgMzUgNTY8"
                          "L3A+PC9kaXY+Cg==")))

              (defun vh/insert-pia-html-sig ()
                (interactive)
                (insert-string vh/pia-html-sig))
     #+end_src
*** Sending mail
    #+begin_src emacs-lisp :noweb yes
      (use-package smtpmail
        :defer
        :config

        (custom-set-variables '(mail-host-address "hallac.net"))

        (setq smtp-accounts '( (ssl "vedathallac@gmail.com" "gmail-1" "smtp.googlemail.com" 587)
                               (ssl "dys.wowace@gmail.com" "gmail-2" "smtp.googlemail.com" 587)
                               (ssl "vedat@android.ciyiz.biz" "gmail-android" "smtp.googlemail.com" 587)
                               (ssl "vedat.hallac@pia-team.com" "gmail-pia" "smtp.googlemail.com" 587)
                               (ssl "vedat.hallac@pia-systems.com" "ms-piasys" "smtp.office365.com" 587)
                               (ssl "vedat@hallac.net" "hallac-net" "smtp.yandex.com" 587)
                               (ssl "vedath@7island.com" "gmail-qbit" "smtp.googlemail.com" 587)
                               (ssl "vedat@wamo.io" "gmail-wamo" "smtp.googlemail.com" 587)))
        <<smtp-switch-helper>>)

      (use-package tls
        :requires smtp-openssl
        :defer
        :config
        (custom-set-variables '(tls-program `(,(concat
                                                (if (boundp 'openssl-prg)
                                                    openssl-prg
                                                  "openssl")
                                                " s_client -connect %h:%p -no_ssl2 -ign_eof"))))
        (require 'smtp-openssl))

      (use-package smtp-openssl
        :ensure t)
    #+end_src
**** Multiple SMTP servers support
     :PROPERTIES:
     :header-args: :tangle no
     :END:

     The code block below will switch the SMTP server in use depending on the
     sender address.

     #+name: smtp-switch-helper
     #+begin_src emacs-lisp
       (use-package gnutls
         :config
         (custom-set-variables '(gnutls-min-prime-bits 1024)))

       ;;; This only works for emacs 24 and (hopefully) above
       (defun set-smtp-common (alias server port &optional user password)
         ;; TODO: I need both alias and real server entries in my authinfo
         ;; for this method. I don't like it. Need a better way to handle it.
         (unless user
           (setq user (plist-get (car (auth-source-search :host alias
                                                          :port 587))
                                 :user)))
         (setq smtpmail-smtp-user user
               smtpmail-smtp-server server
               smtpmail-smtp-service port))

       (defun set-smtp (mech alias server port &optional user password)
         "Set related SMTP variables for supplied parameters."
         (set-smtp-common alias server port user password)
         (setq smtpmail-auth-supported (list mech)
               smtpmail-starttls-credentials nil))

       (defun set-smtp-ssl (alias server port &optional user password key cert)
         "Set related SMTP and SSL variables for supplied parameters."
         (set-smtp-common alias server port user password)
         (setq starttls-use-gnutls nil        ;use starttls-program
               starttls-extra-arguments nil
               smtpmail-starttls-credentials (list (list server port key cert))))

       (defun change-smtp ()
         "Change the SMTP server according to the current from line."
         (save-excursion
           (let ((case-fold-search t))
             (cl-loop with from = (save-restriction
                                 (message-narrow-to-headers)
                                 (message-fetch-field "from"))
                   for (auth-mech address . auth-spec) in smtp-accounts
                   when (string-match address from)
                   do (cond
                       ((memq auth-mech '(cram-md5 plain login))
                        (cl-return (apply 'set-smtp 'auth-mech auth-spec)))
                       ((eql auth-mech 'ssl)
                        (cl-return (apply 'set-smtp-ssl auth-spec)))
                       (t (error "Unrecognized SMTP auth. mechanism: `%s'" auth-mech)))
                   finally (error "Cannot infer SMTP information")))))

       (defadvice smtpmail-via-smtp (around set-smtp-server-from-sender activate)
         "When sending smtp mail, replace credentials according to to From: field"
         ;; Not sure if this is the right way, but it seems to prevent the password
         ;; lingering around in the variable.
         (let ((smtpmail-auth-credentials nil))
           (with-current-buffer smtpmail-text-buffer
             (change-smtp))
           ad-do-it))
     #+end_src
*** Contacts
    #+begin_src emacs-lisp
      (use-package bbdb
        :ensure t
        :defer
        :config
        (custom-set-variables '(bbdb-update-records-p 'query)
                              '(bbdb-mua-update-interactive-p '(search . query))

                              ;; Uncommenting the following allows me to auto-capture e-mails into BBDB
                              ;; '(bbdb-accept-message-alist '( ("From" . "@pia-team\.com")
                              ;;                                ("From" . "@\\(?:milleni\\|turkcell\\)\.com\.tr")))

                              ;; use %uB for names in gnus-summary-line-format configuration
                              '(bbdb-mua-summary-unify-format-letter "B") )
        (setq bbdb/gnus-score-default 10))


    #+end_src

    I am currently using notmuch for sending emails. Auto complete wortks great for me, but accumulating all my emails over more that
    a decade caused lots of old emails to come up as completion candidates for some people. The little package below allows me to filter out these emails.

    For the code, see [[file:./elisp/mine/notmuch-forget.el][notmuch-forget.el]].

    #+begin_src emacs-lisp
      (use-package notmuch-forget
        :init
        (with-eval-after-load "notmuch-address" (notmuch-forget-install)))
    #+end_src
** Projectile
   #+begin_src emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (projectile-register-project-type 'ant '("build.xml")
                                         :compile "ant"
                                         :test "ant test")
       (add-to-list 'projectile-project-root-files "build.xml")
       (projectile-register-project-type 'nodejs '("package.json")
                                         :compile "npm --no-color build"
                                         :test "npm --no-color test")
       (mapc (lambda (x) (add-to-list 'projectile-globally-ignored-directories x))
             (list "node_modules" "target" "bower_components"))

       (custom-set-variables '(projectile-project-root-files-functions '(projectile-root-top-down
                                                                         projectile-root-bottom-up
                                                                         projectile-root-top-down-recurring))
                             '(projectile-enable-caching t))
       (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
       (projectile-global-mode))

     (use-package counsel-projectile
       :ensure t
       :after projectile
       :config
       (counsel-projectile-mode))
   #+end_src
** Programming Languages
*** C
    :PROPERTIES:
    :header-args: :tangle no
    :END:

    #+name: c-setup
    #+begin_src emacs-lisp :noweb yes
      <<c-helper-functions>>
      <<c-styles>>
      (add-hook 'c-mode-hook (lambda ()
                               (c-set-style "tda")))
    #+end_src

**** Key bindings
     #+name: c-bindings
     #+begin_src emacs-lisp
       :bind (:map c-mode-map
                   ("C-c C-f" . c-helper-find-file)
                   ("C-c C-v" . c-helper-find-include-file))

     #+end_src
**** C Mode Styles

     #+name: c-styles
     #+begin_src emacs-lisp
       (c-add-style "tda" '((c-basic-offset . 4)
                            (c-comment-only-line-offset . 0)
                            (c-block-comment-prefix . "*")
                            (c-hanging-braces-alist     . ((substatement-open        before after)
                                                           (brace-list-open          after)
                                                           (brace-list-intro)
                                                           (brace-entry-open         before)
                                                           (brace-list-close  . vh/c-snug-array-close)
                                                           (block-close       . c-snug-do-while)
                                                           (class-open               after)
                                                           (class-close              before)))
                            (c-hanging-colons-alist     . ((case-label after)
                                                           (label after)
                                                           (member-init-intro before)
                                                           (inher-intro)))
                            (c-offsets-alist . ((topmost-intro         . 0)
                                                (topmost-intro-cont    . 0)
                                                (substatement          . +)
                                                (substatement-open     . 0)
                                                (case-label            . 0)
                                                (label                 . 0)
                                                (access-label          . -)
                                                (inclass               . +)
                                                (inline-open           . 0)
                                                (cpp-macro-cont        . ++)
                                                (arglist-intro         . c-lineup-arglist-intro-after-paren)
                                                (arglist-cont          . c-lineup-arglist)
                                                (arglist-cont-nonempty . c-lineup-arglist)
                                                (arglist-close         . c-lineup-arglist)
                                                (inextern-lang         . -)
                                                (statement-cont        . vh/c-lineup-array-init)))
                            (c-cleanup-list . (empty-defun-braces
                                               list-close-comma
                                               scope-operator
                                               one-liner-defun
                                               comment-close-slash))
                            (c-hanging-semi&comma-criteria . (c-semi&comma-inside-parenlist))))

       (c-add-style "eracom" '((c-basic-offset . 4)
                               (c-comment-only-line-offset . 0)
                               (c-block-comment-prefix . "*")
                               (c-hanging-braces-alist     . ((substatement-open        before after)
                                                              (brace-list-open          after)
                                                              (brace-list-intro)
                                                              (brace-entry-open         before)
                                                              (brace-list-close  . vh/c-snug-array-close)
                                                              (block-close       . c-snug-do-while)
                                                              (class-open               after)
                                                              (class-close              before)))
                               (c-hanging-colons-alist     . ((case-label after)
                                                              (label after)
                                                              (member-init-intro before)
                                                              (inher-intro)))
                               (c-offsets-alist . ((topmost-intro         . 0)
                                                   (topmost-intro-cont    . 0)
                                                   (substatement          . +)
                                                   (substatement-open     . 0)
                                                   (case-label            . 0)
                                                   (label                 . 0)
                                                   (access-label          . -)
                                                   (inclass               . +)
                                                   (inline-open           . 0)
                                                   (cpp-macro-cont        . ++)
                                                   (arglist-intro         . c-lineup-arglist-intro-after-paren)
                                                   (arglist-cont          . c-lineup-arglist)
                                                   (arglist-cont-nonempty . c-lineup-arglist)
                                                   (arglist-close         . c-lineup-arglist)
                                                   (inextern-lang         . -)
                                                   (statement-cont        . vh/clineup-array-init)))
                               (c-cleanup-list . (empty-defun-braces
                                                  list-close-comma
                                                  scope-operator))
                               (c-hanging-semi&comma-criteria . (c-semi&comma-inside-parenlist))))

       (c-add-style "eracom-old" '((c-basic-offset . 4)
                                   (c-comment-only-line-offset . 0)
                                   (c-block-comment-prefix . "*")
                                   (c-hanging-braces-alist     . ((substatement-open after)
                                                                  (brace-list-open   after)
                                                                  (brace-list-intro)
                                                                  (brace-entry-open  after)
                                                                  (brace-list-close  before)
                                                                  (block-close       . c-snug-do-while)
                                                                  (class-open        after)))
                                   (c-hanging-colons-alist     . ((case-label after)
                                                                  (label after)
                                                                  (member-init-intro before)
                                                                  (inher-intro)))
                                   (c-offsets-alist . ((topmost-intro         . 0)
                                                       (topmost-intro-cont    . 0)
                                                       (substatement          . +)
                                                       (substatement-open     . 0)
                                                       (case-label            . 0)
                                                       (label                 . 0)
                                                       (access-label          . -)
                                                       (inclass               . +)
                                                       (inline-open           . 0)
                                                       (cpp-macro-cont        . ++)
                                                       (arglist-intro         . c-lineup-arglist-intro-after-paren)
                                                       (arglist-cont          . c-lineup-arglist)
                                                       (arglist-cont-nonempty . c-lineup-arglist)
                                                       (arglist-close         . c-lineup-arglist)))
                                   (c-cleanup-list . (brace-else-brace
                                                      brace-elseif-brace
                                                      empty-defun-braces
                                                      list-close-comma
                                                      scope-operator))))


       (defun vh/c-snug-array-close (syntax pos)
         "Dynamically calculate close-brace hanginess for array initializations.

       See `c-hanging-braces-alist' for how to utilize this function as an
       ACTION associated with `brace-list-close' syntax."
         (save-excursion
           (if (eq syntax 'brace-list-close)
               (match-parenthesis 0))
           (c-safe (c-forward-token-1 -1))
           (if (eq (char-after) ?\=)
               '(before)
             '(after))))

       (defun vh/c-lineup-array-init (langelem)
         "Correct the indentation of array and structure initializer brace, when it is
       reported as statement-cont.

       Changes:
       int a[] =             int a[] =
          {                  {
             1,2,3      ->      1,2,3
          };                 };"
         (let ((default-lineup (c-lineup-math langelem)))
           (save-excursion
             (goto-char (point-at-bol))
             (if (and (looking-at "\\s-*{")
                      (progn (c-safe (c-backward-token-1 1))
                             (eq (char-after) ?\=)))
                 0
               default-lineup))))
     #+end_src
**** Helper functions
     #+name: c-helper-functions
     #+begin_src emacs-lisp
       (require 'etags)

       (defvar c-helper-find-file-history nil)
       (defvar c-helper-global-search-list nil)
       (defvar c-helper-buffer-specific-dir-hook nil)

       (defun c-helper-find-file (&optional filename)
         "Finds the file in the current include path.
       See c-helper-include-path for the current include path."
         (interactive)
         (progn
      	 (if (or (not filename)
      			 (eq (string-width filename) 0))
      		 (setq filename (read-string "Please enter the file name: "
                                           ""
                                           'c-helper-find-file-history
                                           "")) )
      	 (let ((dirs (append c-helper-global-search-list
                               (if (functionp c-helper-buffer-specific-dir-hook)
                                   (funcall c-helper-buffer-specific-dir-hook)
                                 nil))))
                                               ; Try to find in the tag list, if appropriate
      	   (if (buffer-tag-table-list)
      		   (let ((fname (c-helper-find-in-tags filename)))
      			 (if fname
      				 (progn
                         (if (> (count-windows) 1)
                             (find-file-other-window fname)
                           (find-file fname))
                         (return nil)))))

                                               ; Otherwise, try the specified directories
      	   (if dirs
      		   (let ((fname (c-helper-find-under-dirs dirs filename)))
      			 (if fname
      				 (if (> (count-windows) 1)
      					 (find-file-other-window fname)
      				   (find-file fname))
      			   (error (concat "Cannot find file: " filename))))
      		 (error "Cannot construct search path")))))


       (defun c-helper-find-in-tags (filename)
         "Locates a file in the buffer's tag files.
       Returns the absolute path to the file, if found in the TAGS list,
       otherwise return nil."
         (let ((files (buffer-tag-table-files))
               (name nil))
           (while (and files (null name))
             (if (partial-file-path-match (car files) filename)
                 (setq name (car files)))
             (setq files (cdr files)))
           (if name
               (expand-file-name name))))

       (defun c-helper-find-under-dirs (dirlist filename)
         "Locate the file under DIRLIST.
       If the same file appears more than once in the directory list, the one closest
       to the top list of directories is found."
         (let ((name nil))
           (while dirlist
             (let* ((dir (car dirlist))
                    (contents (directory-files dir t))
                    (files nil)
                    (dirs nil))
               (mapc #'(lambda (name)
                        (cond ((and (file-directory-p name)
                                    (not (member
                                          (file-name-nondirectory name)
                                          '("." ".." "cvs" "CVS" "rcs" "RCS" ".svn"))))
                               (setq dirs (cons name dirs)))
                              ((and (not (file-directory-p name))
                                    (file-readable-p name))
                               (setq files (cons (convert-standard-filename name) files))))
                        nil)
                     contents)
               (while (and files (null name))
                 (if (partial-file-path-match (car files) filename)
                     (setq name (car files)))
                 (setq files (cdr files)))
               (setq dirlist (append (cdr dirlist) dirs)))
             (if name
                 (setq dirlist nil)))
           name))

       (defun partial-file-path-match (full-path partial-path)
         "Compare a full (at least fuller) path against a sub-path.
       If the trailing parts of two paths match, returns t. Otherwise, returns nil.
       For example \"/usr/local/bin/emacs\" vs \"bin/emacs\" returns t."
         (let ((match t))
           (while (and match partial-path)
             (let ((full-last (file-name-nondirectory full-path))
                   (partial-last (file-name-nondirectory partial-path)))
               (if (or (null partial-last)
                       (string-equal partial-last ""))
                   (setq partial-path nil)
                 (setq match (string-equal full-last partial-last))
                 (setq full-path (file-name-directory full-path))
                 (setq partial-path (file-name-directory partial-path))
                 (if full-path
                     (setq full-path (directory-file-name full-path)))
                 (if partial-path
                     (setq partial-path (directory-file-name partial-path))))))
           match))


       (defun c-helper-find-include-file ()
         "Extracts the include file from the line under the point,
       and finds it in the search path."
         (interactive)
         (save-excursion
      	 (beginning-of-line)
      	 (if (search-forward-regexp "#include\\s-*[\\\"<]\\(.*\\)[\\\">]"
      							    (point-at-eol) ; limit
      							    t ; noerror
      							    )
      		 (let ((file-name (buffer-substring-no-properties
                                 (match-beginning 1) (match-end 1))))
      		   (if file-name
      			   (c-helper-find-file file-name)
      			 (error "No file specified in the #include statement")))
      	   (error "Not on a line with a #include statement"))))
     #+end_src
*** Java
    :PROPERTIES:
    :header-args: :tangle no
    :END:

    Java mode configuration.

    #+name: java-setup
    #+begin_src emacs-lisp :noweb yes
      <<java-styles>>
      (add-hook 'java-mode-hook (lambda ()
                                  (subword-mode)
                                  (c-set-style "java-custom")))
    #+end_src


**** Java mode styles
     #+NAME: java-styles
     #+begin_src emacs-lisp
       (c-add-style "java-custom"
                    '("java"
                      (c-offsets-alist . ((substatement-open . 0)
                                          (arglist-cont-nonempty . (c-lineup-cascaded-calls
                                                                    c-lineup-argcont))
                                          (statement-cont . (c-lineup-cascaded-calls
                                                             c-lineup-assignments))))
                      (c-hanging-braces-alist . ((class-open after)
                                                 (inexpr-class-open after)
                                                 (inexpr-class-close before)
                                                 (defun-open after)
                                                 (inline-open after)
                                                 (substatement-open after)
                                                 (block-close . c-snug-do-while)))))


     #+end_src
**** DISABLED Eclim

     Eclipse in emacs. This package uses a plugin to communicate with eclipse, and get it to do the heavy lifting.

     I had limited success with it.

     #+begin_src emacs-lisp
       (use-package eclim
         :disabled
         :commands (eclim-manage-projects global-eclim-mode)
         :config
         (setq eclim-auto-save t 		; Need to save before analyzing class
               help-at-pt-display-when-idle t
               eclim-executable (concat eclipse-dir "eclim"))

         (help-at-pt-set-timer)

         (add-hook 'eclim-mode-hook
                   (lambda ()
                     (require 'auto-complete-config)
                     (ac-config-default)
                     (add-to-list 'ac-sources 'ac-source-eclim)))) ; ac-source-emacs-eclim is also available

       (use-package eclimd
         :disabled
         :commands start-eclimd
         :config (setq eclimd-executable (concat eclipse-dir "eclimd")
                       eclimd-default-workspace "~/work"))


     #+end_src
*** C# Mode
    Basic c# processing.

    Emacs and dotnet command line tool do not agree with each other. Use a
    script called ncdotnet that pipes the output through ~sed
    's/\x1b\[[0-9;]*m//g'~ to strip color.

    #+begin_src emacs-lisp
      (use-package csharp-mode
        :ensure t
        :commands (csharp-mode)
        :mode ("\\.cs" . csharp-mode)
        :hook (csharp-mode . vh/csharp-mode-func)
        :bind* (:map csharp-mode-map
                     ("C-c . R" . #'vh/dotnet--restore)
                     ("C-c . ." . #'vh/dotnet--build)
                     ("C-c . T" . #'vh/dotnet--test))
        :config
        (defun vh/csharp-mode-func ()
          (subword-mode 1))

        (defun vh/dotnet--project-root ()
          (locate-dominating-file default-directory
                                  (lambda (parent) (directory-files parent nil ".*\\.csproj"))))

        (defun vh/dotnet--run-dotnet (sub &rest args)
          "Run the dotnet utility.

      SUB is the sub command. ARGS are additional arguments, if any"
          (interactive "Msub command:")
          (let ((default-directory (vh/dotnet--project-root)))
            (compile (concat "ncdotnet " sub
                             (apply #'concat args)))))

        (defmacro vh/define-dotnet-command (subcommand)
          "Defines a command VH/DOTNET--,SUBCOMMAND

      The command will invoke the specified subcommand in the project directory"
          (let ((fname (intern (concat "vh/dotnet--" subcommand))))
            `(defun ,fname  (&rest args)
               (interactive)
               (apply #'vh/dotnet--run-dotnet (cons ,subcommand args)))))

        (vh/define-dotnet-command "build")
        (vh/define-dotnet-command "test")
        (vh/define-dotnet-command "restore"))
    #+end_src

    Advanced editing requires Omnisharp mode
    #+begin_src emacs-lisp
      (use-package omnisharp
        :ensure t
        :commands (omnisharp-mode)
        :hook (csharp-mode . vh/omnisharp-csharp-func)
        :bind* (:map omnisharp-mode-map
                     ("M-<RET>" . #'omnisharp-run-code-action-refactoring)
                     ("C-c . <RET>" . #'omnisharp-run-code-action-refactoring)
                     ("C-c . r" . #'omnisharp-rename)
                     ("C-c . t" . #'vh/omnisharp-unit-test-at-point)
                     ("C-c . g d" . #'omnisharp-go-to-definition)
                     ("C-c . g D" . #'omnisharp-go-to-definition-other-window)
                     ("C-c . R" . #'omnisharp-run-code-action-refactoring)
                     ("C-c . U" . #'omnisharp-fix-usings)
                     ("C-c . g u" . #'omnisharp-find-usages)
                     ("C-c . g i" . #'omnisharp-find-implementations)
                     ("C-c . C-i" . #'omnisharp-auto-complete)
                     )
        :init
        (custom-set-variables '(omnisharp-server-executable-path "~/.emacs.d/.cache/omnisharp/server/v1.34.5/run"))
        :config
        (defun vh/omnisharp-csharp-func ()
          (omnisharp-mode)
          (auto-complete-mode))

        (defun vh/omnisharp--namespace-of (stack)
          (-let (((&alist 'Kind kind
                          'Name name) (car stack)))
            (when (not (equal "namespace" kind))
              (error (concat "Expected namespace, got " kind)))
            name))

        (defun vh/omnisharp--class-of (stack)
          (let ((last-class (last (delq nil
                                        (mapcar (lambda (x)
                                                  (-let (((&alist 'Kind kind) x))
                                                    (when (equal kind "class") x))) stack)))))
            (-let (((&alist 'Name name) (car last-class)))
              name)))

        (defun vh/omnisharp--method-of (stack)
          (-let (((&alist 'Kind kind
                          'Name name) (car (last stack))))
            (when (equal "method" kind) name)))

        (defun vh/omnisharp-unit-test-at-point ()
          "Runs test case under point, if any."
          (interactive)
          (omnisharp--cs-element-stack-at-point
           (lambda (stack)
             (let ((default-directory (vh/dotnet--project-root))
                   (method (vh/omnisharp--method-of stack)))
               (compile (concat "ncdotnet test --filter="
                                (vh/omnisharp--namespace-of stack)
                                "."
                                (vh/omnisharp--class-of stack)
                                (when method
                                  (concat
                                   "."
                                   (vh/omnisharp--method-of stack))))))))))
    #+end_src
*** Maven
    Build your java applications easily.

    Maven output may contain ANSI colors. I advise the =mvn= function to
    suppress ANSI color codes, so that the compile buffer is readable again.
    While I am at it, I reduce clutter from mvn using the '-q' flag. This is
    done in the =:init= section below.

    I also add two mvn-test extensions to speed up the test cycle here. The
    functions I use were adapted from [[https://gist.github.com/bahmanm/c11c94d2158eb1113879][this github gist]].

    #+begin_src emacs-lisp
      (use-package mvn
        :ensure t
        :after cc-mode
        :commands (mvn-test-defun mvntest-class)
        :bind (:map java-mode-map
                    ("C-c t c" . mvn-test-class)
                    ("C-c t f" . mvn-test-defun))
        :init
        ;; Neither clutter nor color from mvn, please
        (defun vh/mvn--plain-output (&optional old-function task args &rest future-args)
          (apply old-function task (concat "-q -B " args) future-args))

        (advice-add #'mvn :around #'vh/mvn--plain-output)

        :config
        (defun mvn-test-class ()
          (interactive)
          (let* ((file-name (buffer-file-name))
                 (class-name (car (split-string
                                   (car (last (split-string file-name "/")))
                                   "\\.")))
                 (root (projectile-project-root)))
            (mvn-test class-name)))

        ;; prompts for a single test case in the current class and runs it

        (defun java-method-name ()
          (require 'imenu)
          (imenu--menubar-select imenu--rescan-item)
          (save-excursion
            (let ((beg-pt (progn (beginning-of-defun)
                                  (point)))
                  (end-pt (progn (end-of-defun)
                                 (point))))
              (car (delq nil
                         (mapcar (lambda (x) (let ((pos (cdr x)))
                                               (when (and
                                                      (>= pos beg-pt) (<= pos end-pt))
                                                 (car x))))
                                 (imenu--make-index-alist)))))))

        (defun mvn-test-defun ()
          (interactive)
          (require 'imenu)
          (let* ((file-name (buffer-file-name))
                 (class-name (car (split-string
                                   (car (last (split-string file-name "/")))
                                   "\\.")))
                 (test-case (java-method-name))
                 (root (projectile-project-root))
                 (mvn-cmd (concat "cd " root " && "
                                  "mvn -Dtest=" class-name "#" test-case " test ")))
            (mvn-test (concat class-name (when test-case (concat "#" test-case)))))))
    #+end_src
*** Groovy

    #+begin_src emacs-lisp
      (use-package groovy-mode
        :ensure t
        :commands groovy-mode
        :mode ("\\.gradle$" . groovy-mode))
    #+end_src
*** Ruby

    #+begin_src emacs-lisp
      (use-package ruby-mode
        :commands ruby-mode
        :after auto-complete
        :mode ("\\(?:\\.\\(?:gemspec\\|r\\(?:ake\\|[ub]\\)\\)\\|Gemfile\\)\\$" . ruby-mode)
        :bind (:map ruby-mode-map
                    ("C-x C-t" . ruby-compilation-this-rspec)
                    ;;("C-c C-d" . yari-anything)
                    ("#" . ruby-electric-strparam)
                    ("C-M-u" . ruby-goto-containing-block-start)
                    ("C-c b" . ruby-flip-containing-block-type))
        :config
        (require 'ruby-helper)
        (autoload 'word-at-point "thingatpt.el")

        (require 'auto-complete-config)

        (require 'align)
        (defconst align-ruby-modes '(ruby-mode))
        (defconst ruby-align-rules-list
          '((ruby-comma-delimiter
             (regexp . ",\\(\\s-*\\)[^/ \t\n]")
             (modes  . align-ruby-modes)
             (repeat . t))
            (ruby-symbol-after-func
             (regexp . "^\\s-*\\w+\\(\\s-+\\):\\w+")
             (modes  . align-ruby-modes))))
        (add-to-list 'align-perl-modes 'ruby-mode)
        (add-to-list 'align-dq-string-modes 'ruby-mode)
        (add-to-list 'align-sq-string-modes 'ruby-mode)
        (add-to-list 'align-open-comment-modes 'ruby-mode)
        (dolist (it ruby-align-rules-list)
          (add-to-list 'align-rules-list it))

        (add-hook 'ruby-mode-hook (lambda ()
                                    (auto-complete-mode t)
                                    ;; Auto-complete fixups
                                    (make-local-variable 'ac-ignores)
                                    (add-to-list 'ac-ignores "end")))

        (defun vh/projectile-test-prefix (orig-fun project-type &rest args)
          (let ((val
                 (or (cond
                      ((member project-type '(ruby)) "test_"))
                     (apply orig-fun project-type args))))
            val
            ))
        (advice-add 'projectile-test-prefix :around #'vh/projectile-test-prefix))

      (use-package inf-ruby
        :ensure t)

      (use-package rake
        :ensure t
        :after projectile
        :config
        (projectile-register-project-type 'ruby '("Rakefile")
                                          :compile "rake"
                                          :test "rake test"))

      (use-package rbenv
        :ensure t
        :config
        (let ((path (getenv "PATH")))
          (when (not (string-match-p "\\.rbenv/shims" path))
            (setenv "PATH" (concat path path-separator (expand-file-name "~/.rbenv/shims"))))))

      (use-package bundler
        :ensure t)
    #+end_src

**** DISABLED On Rails
     #+begin_src emacs-lisp
       (use-package rspec-mode
         :disabled
         :commands rspec-mode
         :config
         (autoload 'ruby-electric-mode "ruby-electric.el")

         (add-hook 'rspec-mode-hook (lambda ()
                                      ;;(require 'rinari)
                                      ;;(require 'ruby-compilation-rspec)
                                      (require 'auto-complete-config)
                                      ;;(ruby-electric-mode t)
                                      (auto-complete-mode t)
                                      ;; Auto-complete fixups
                                      (make-local-variable 'ac-ignores)
                                      (add-to-list 'ac-ignores "end"))))

       (use-package rhtml-mode
         :disabled
         :commands rhtml-mode
         :mode ("\\.html\\.erb\\'" . rhtml-mode))
     #+end_src
*** Lisp

    #+begin_src emacs-lisp
      (use-package lisp-mode
        :after paredit
        :config
        (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
        (add-hook 'lisp-mode-hook #'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode))

      (use-package elisp-helper
        :bind (("C-c e" . vh-eval-and-replace)))
    #+end_src
**** Scheme

     #+begin_src emacs-lisp
       (use-package scheme
         :commands scheme-mode
         :mode ("\\.s\\(s\\|c[mh]\\)$" . scheme-mode))
     #+end_src
**** Slime (Common Lisp)

     #+begin_src emacs-lisp
       (use-package slime
         :disabled
         :config
         (add-to-list 'lisp-mode-hook 'slime-mode)

         (slime-setup)
         (add-to-list slime-lisp-implementations `((sbcl ("sbcl"))
                                                   (cmucl ("lisp"))
                                                   (openmcl ("openmcl"))
                                                   (s48 ("scheme48") :init slime48-init-command)
                                                   (s48-large ("scheme48" "-h" "80000000")
                                                              :init slime48-init-command)
                                                   (abcl ("abcl"))))
         ;;  (setq inferior-lisp-program "sbcl")
         )


     #+end_src
*** Python
    #+begin_src emacs-lisp
      (use-package python
        :commands python-mode
        :requires auto-complete
        :mode  ("\\.py$" . python-mode)
        :interpreter ("python" . python-mode)
        :config
        (require 'auto-complete)
        (require 'auto-complete-config)

        (add-hook 'python-mode-hook
                  (lambda ()
                    (custom-set-variables '(ropemacs-enable-autoimport t)
                                          ;; Automatically save project python buffers before refactorings
                                          '(ropemacs-confirm-saving 'nil))
                    (unless (featurep 'ropemacs)
                      (pymacs-load "ropemacs" "rope-" t)
                      (ropemacs-mode 1))
                    (auto-complete-mode 1)
                    (ac-ropemacs-setup))))

      (use-package pymacs
        :commands pymacs-load)
    #+end_src
**** Virtual Environments
     #+begin_src emacs-lisp
       (use-package virtualenv
         :ensure t
         :commands virtualenv-activate
         :config (defvar virtualenv-use-ipython nil))
     #+end_src
*** Javascript
    #+begin_src emacs-lisp
      (use-package js2-mode
        :ensure t
        :requires yasnippet
        :mode ("\\.js\\'" . js2-mode)
        :config
        (yas-reload-all)
        (add-hook 'js2-mode-hook #'yas-minor-mode-on)
        (custom-set-variables '(js2-indent-switch-body t))
        ;; This is for jasmine output. But it needs more work
        (add-to-list 'compilation-error-regexp-alist '("^\\W+at\\(.*\\)\\ (\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\)" 2 3 4)))
    #+end_src
*** Lua
    #+begin_src emacs-lisp
      (use-package lua-mode
        :ensure t
        :commands lua-mode
        :config
        (add-hook 'lua-mode-hook #'(lambda ()
                                    (setq lua-electric-mode nil
                                          lua-indent-level 4)
                                    ;; (choose-indent-type)
                                    (auto-fill-mode 1)
                                    (subword-mode 1))))
    #+end_src
*** Golang
    #+begin_src emacs-lisp
      (use-package go-mode
        :ensure t)
    #+end_src
*** C-Like languages (/cc-mode/)

    Emacs programming languages that look like C are usually defined in
    /cc-mode/ package. This makes it hard to separate the setup for these
    languages to different sections in my configuration file using the
    =use-package= infrastructure.

    This section provides the statements for =use-package= and the individual
    language modes are defined in their respective headings. When tangling the
    init file, we pull in the individual setups.

    #+begin_src emacs-lisp :noweb yes
      (use-package cc-mode
        <<c-bindings>>
        <<java-bindigs>>
        :config
        ;; These are common settings for all cc modes
        (custom-set-variables '(c-echo-syntactic-information-p t)
                              '(c-electric-pound-behavior '(alignleft))
                              '(c-indent-comments-syntactically-p t))
        (setq c-macro-shrink-window-flag t)
        (add-hook 'c-mode-common-hook (lambda ()
                                        (auto-fill-mode t)
                                        (auto-complete-mode)))
        <<c-setup>>
        <<java-setup>>)
    #+end_src
*** Flycheck
    #+begin_src emacs-lisp :noweb yes
      (use-package flycheck
        :ensure t
        :bind (:map flycheck-mode-map ("C-c ! !" . org-time-stamp-inactive))
        :init
        (global-flycheck-mode)
        :config
        <<flycheck-config-js>>
        <<flycheck-config-elisp>>
        (custom-set-variables '(flycheck-temp-prefix "#flycheck")))
    #+end_src
**** Javascript
     I use =eslint= instead of =jshint= in flycheck.

     #+name: flycheck-config-js
     #+begin_src emacs-lisp :tangle no
       (add-hook 'js2-mode-hook (lambda nil
                                  (add-to-list 'flycheck-disabled-checkers 'javascript-jshint)))
       ;;; Use "sudo npm install -g eslint"
       (custom-set-variables '(flycheck-javascript-eslint-executable "/usr/local/bin/eslint"))
     #+end_src
**** elisp
     #+name: flycheck-config-elisp
     #+begin_src emacs-lisp :tangle no
       (custom-set-variables '(flycheck-emacs-lisp-load-path 'inherit))
       (add-hook 'emacs-lisp-mode-hook (lambda nil
                                         (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc)))
     #+end_src
**** java
     A flycheck module that uses eclipse's ecj.jar to check java files.

     This package is not in ELPA yet, so it is loaded as a git submodule. I
     check whether the submodule is available, then check if ecj.jar is
     available (I will not commit a binary to git). If both conditions are
     satisfied, I will initialize the module.

     #+begin_src emacs-lisp
       (let* ((flycheck-java-dir "~/.emacs.d/elisp/thirdparty/flycheck-java")
              (bin-dir "~/.emacs.d/bin")
              (ecj-jar-file (when (file-directory-p bin-dir)
                              (car (last (directory-files  bin-dir t "ecj.*jar"))))))
         (when (and ecj-jar-file
                    (file-exists-p flycheck-java-dir))
           (setq load-path (cons flycheck-java-dir load-path))
           (use-package flycheck-java
             :config
             (setq flycheck-java-ecj-jar-path ecj-jar-file))))
     #+end_src
*** Navigation

    Packages in here allow fast navigation in programming languages.

    Dumb-jump is an almost zero-config pacakge that finds the definition of keyword under cursor.

    #+begin_src emacs-lisp
      (use-package dumb-jump
        :ensure t
        :bind (("M-g d" . dumb-jump-go)
               ("M-g D" . dumb-jump-go-other-window)
               ("M-g b" . dumb-jump-back)))
    #+end_src
*** Haskell

    #+begin_src emacs-lisp
      (use-package haskell-mode
        :ensure t
        :config
        (setq flycheck-ghc-args "-dynamic")
        (custom-set-variables '(haskell-compile-command "ghc -dynamic -Wall -ferror-spans -fforce-recomp -c %s")))
    #+end_src
** YAML
   #+begin_src emacs-lisp
     (use-package yaml-mode :ensure t
       :hook (yaml-mode . (lambda ()
                            (wucuo-start)
                            (subword-mode)
                            (auto-fill-mode))))
   #+end_src
** XML editing

   NXML is a good way to edit XML files in emacs. Its biggest drawback is that
   is uses Realx NG schemas instead of XSD/DTD. The schema files I have
   collected all live under ~nxml-schemas~ inside ~.emacs.d~ directory.

   I use the external tool =xmlindent= to indent entire XML file. You can
   install this utility by running ~sudo apt install xmlindent~.

   #+begin_src emacs-lisp
     (use-package nxml-mode
       :commands nxml-mode
       :bind (:map nxml-mode-map
                   ("C-c k c" . comment-region)
                   ("C-c k i" . indent-xml-file))
       :mode ("\\.\\(x[ms]l\\|rng\\|x?html?\\)\\'" . nxml-mode)
       :config
       (setq nxml-child-indent 4
             nxml-outline-child-indent 4
             nxml-slash-auto-complete-flag nil)
       (defun indent-xml-file ()
         "Indent entire XML file"
         (interactive "")
         (shell-command-on-region (point-min) (point-max) "xmlindent" (current-buffer) t))

       (add-hook 'nxml-mode-hook
                 #'(lambda ()
                    ;; (choose-indent-type)
                    ;; Add my schema files to RNG search path
                    (add-to-list 'rng-schema-locating-files
                                 "~/.emacs.d/nxml-schemas/schemas.xml")
                    (add-to-list 'rng-schema-locating-files
                                 "~/.emacs.d/nxml-schemas/libvirt/schemas.xml"))))
   #+end_src
** Org mode

   I can't even get my configuration to work without org mode. So yes, I will install it.

   I explicitly pull in the org-plus-contrib package available from the org-mode archive.

   #+begin_src emacs-lisp :noweb yes
     (use-package org
       :ensure org-plus-contrib
       :hook (org-mode . (lambda ()
                           (wucuo-start)
                           (auto-fill-mode)))
       :bind (("C-c b o"   . org-switchb)
              ("C-c b 4 o" . org-switch-to-buffer-other-window)
              ("C-c l"     . org-store-link))

       :defer
       :init
       (defun vh/revert-org-insert-heading-arg-behavior (&optional old-function arg
                                                                   invisible-ok top &rest future-args)
         "Revert behavior of M-RET.

     When arg is not provided, respect content; when it is 4, insert heading
     immediately after current heading."
         (message (if (not  arg) "nil"))
         (let ((arg (cond ((equal arg '(4)) nil)
                          ((not arg) '(4))
                          (t nil))))
           (message "coo")
           (message (if (not  arg) "nil"))
           (apply old-function arg invisible-ok top future-args)))

       (advice-add #'org-insert-heading :around #'vh/revert-org-insert-heading-arg-behavior)
       :config
       (setq org-hide-leading-stars t
             org-log-done 'time
             org-log-reschedule 'note
             org-log-redeadline 'note
             org-log-into-drawer "LOGBOOK"
             org-return-follows-link t
             org-special-ctrl-a/e t
             org-treat-S-cursor-todo-selection-as-state-change nil
             ;; Column view and estimates
             org-columns-default-format "%80ITEM(Task) %7TODO(To Do) %10Effort(Estim){:} %10CLOCKSUM{+}"
             org-global-properties '(("Effort_ALL" . "0:0 0:10 0:30 1:00 2:00 3:00 4:00 8:00"))
             org-time-clocksum-format '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)
             ;; Mark a task as DONE when archiving
             org-archive-mark-done nil
             org-src-fontify-natively t
             org-time-clocksum-use-effort-durations t
             org-M-RET-may-split-line '((default . nil)))
       (custom-set-variables '(org-tags-column 0))
       (unbind-key "C-c ;" org-mode-map)
       (unbind-key "C-c C-x C-s" org-mode-map)
       (add-to-list 'org-modules 'org-habit)
       <<org-support-funcs>>
       )
   #+end_src
*** Agenda setup
    Notes:
    * I set up weeks to start on Saturday. This is for weekly review purposes.
    * Log display ondy adds clock time

    #+begin_src emacs-lisp
      (use-package org-agenda
        :after org
        :bind (("C-c a" . org-agenda))
        :config
        (require 'org-helper)
        (custom-set-variables
         '(org-agenda-start-on-weekday 6)
         '(org-agenda-span 'day)
         '(org-agenda-include-all-todo t)
         '(org-agenda-time-grid '((daily today) (800 1000 1200 1400 1600 1800 2000) "......" "----------------"))
         '(org-agenda-log-mode-items '(clock))
         '(org-agenda-custom-commands '(("u" "Unscheduled" todo ""
                                         ((org-agenda-todo-ignore-scheduled t)))
                                        ("N" "Notes" tags "NOTE"
                                         ((org-agenda-overriding-header "Notes")
                                          (org-tags-match-list-sublevels t)))
                                        ("h" "Habits" tags-todo "STYLE=\"habit\""
                                         ((org-agenda-overriding-header "Habits")
                                          (org-agenda-sorting-strategy
                                           '(todo-state-down effort-up category-keep))))
                                        (" " "Agenda"
                                         ((agenda "" nil)
                                          (tags "REFILE"
                                                ((org-agenda-overriding-header "Tasks to Refile")
                                                 (org-tags-match-list-sublevels nil)))
                                          (tags-todo "-CANCELLED/!"
                                                     ((org-agenda-overriding-header "Stuck Projects")
                                                      (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                                                      (org-agenda-sorting-strategy
                                                       '(priority-down category-keep))))
                                          (tags-todo "-HOLD-CANCELLED/!"
                                                     ((org-agenda-overriding-header "Projects")
                                                      (org-agenda-skip-function 'bh/skip-non-projects)
                                                      (org-agenda-sorting-strategy
                                                       '(priority-down category-keep))))
                                          (tags-todo "-CANCELLED/!NEXT"
                                                     ((org-agenda-overriding-header "Project Next Tasks")
                                                      (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                                                      (org-tags-match-list-sublevels t)
                                                      (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                                      (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                                      (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                                      (org-agenda-sorting-strategy
                                                       '(priority-down todo-state-down effort-up category-keep))))
                                          (tags-todo "-REFILE-CANCELLED-WAITING/!"
                                                     ((org-agenda-overriding-header (if (marker-buffer org-agenda-restrict-begin) "Project Subtasks" "Standalone Tasks"))
                                                      (org-agenda-skip-function 'bh/skip-project-tasks-maybe)
                                                      (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                                      (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                                      (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                                      (org-agenda-sorting-strategy
                                                       '(category-keep)))
                                                     (tags-todo "-CANCELLED+WAITING/!"
                                                                ((org-agenda-overriding-header "Waiting and Postponed Tasks")
                                                                 (org-agenda-skip-function 'bh/skip-stuck-projects)
                                                                 (org-tags-match-list-sublevels nil)
                                                                 (org-agenda-todo-ignore-scheduled 'future)
                                                                 (org-agenda-todo-ignore-deadlines 'future))))
                                          (tags "-REFILE/"
                                                ((org-agenda-overriding-header "Tasks to Archive")
                                                 (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                                                 (org-tags-match-list-sublevels nil))))
                                         nil)
                                        ("r" "Tasks to Refile" tags "REFILE"
                                         ((org-agenda-overriding-header "Tasks to Refile")
                                          (org-tags-match-list-sublevels nil)))
                                        ("#" "Stuck Projects" tags-todo "-CANCELLED/!"
                                         ((org-agenda-overriding-header "Stuck Projects")
                                          (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                                        ("n" "Next Tasks" tags-todo "-WAITING-CANCELLED/!NEXT"
                                         ((org-agenda-overriding-header "Next Tasks")
                                          (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                                          (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                          (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                          (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                          (org-tags-match-list-sublevels t)
                                          (org-agenda-sorting-strategy
                                           '(todo-state-down effort-up category-keep))))
                                        ("R" "Tasks" tags-todo "-REFILE-CANCELLED/!-HOLD-WAITING"
                                         ((org-agenda-overriding-header "Tasks")
                                          (org-agenda-skip-function 'bh/skip-project-tasks-maybe)
                                          (org-agenda-sorting-strategy
                                           '(category-keep))))
                                        ("p" "Projects" tags-todo "-HOLD-CANCELLED/!"
                                         ((org-agenda-overriding-header "Projects")
                                          (org-agenda-skip-function 'bh/skip-non-projects)
                                          (org-agenda-sorting-strategy
                                           '(category-keep))))
                                        ("W" "Waiting Tasks" tags-todo "-CANCELLED+WAITING/!"
                                         ((org-agenda-overriding-header "Waiting and Postponed tasks"))
                                         (org-tags-match-list-sublevels nil))
                                        ("A" "Tasks to Archive" tags "-REFILE/"
                                         ((org-agenda-overriding-header "Tasks to Archive")
                                          (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                                          (org-tags-match-list-sublevels nil)))
                                        ("w" "Weekly review" agenda ""
                                         ((org-agenda-span 7) (org-agenda-log-mode 1)))))
         '(org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
         '(org-agenda-clockreport-parameter-plist '(:link nil :maxlevel 2))
         '(org-agenda-day-face-function #'jd:org-agenda-day-face-holidays-function)
         '(org-agenda-include-diary t))

        ;; Monkey patch agenda dimmed task function to skip tasks blocked by checkboxes
        (defadvice org-agenda-dim-blocked-tasks (around vh/org-agenda-dont-dim-checkbox-blocks activate)
          (let ((org-blocker-hook org-blocker-hook))
            (remove-hook 'org-blocker-hook 'org-block-todo-from-checkboxes)
            ad-do-it))

        ;; Merge gcal outputs to agenda views
        (require 'org-agenda-gcalcli)
        (add-hook 'org-agenda-finalize-hook 'vh/append-to-day-reports)

        ;; Search all my org files
        (let* ((all-files (apply 'append (mapcar (lambda (dir)
                                                   (directory-files dir t ".*\\.org$"))
                                                 (recursive-directory-list "~/org"))))
               (extra-files (delq nil (mapcar (lambda (extra-file)
                                                (unless (member extra-file org-agenda-files)
                                                  extra-file))
                                              all-files))))
          (customize-set-variable 'org-agenda-text-search-extra-files extra-files)))
    #+end_src
**** Reports
     * Key sequence to prepare clock report parameters (no links, 2 levels deep)
       : C-c a < a v m b R
      + ~<~ restricts to buffer (only once)
      + ~a~ opens agenda
      + ~v m~ scope => month
      + ~b~ last month
      + ~R~ add clock report

*** Exporting

    #+begin_src emacs-lisp
      (use-package ox
        :after org
        :bind (:map org-mode-map
                    ("C-c C-p" . org-publish-current-project))
        :config
        (custom-set-variables '(org-publish-use-timestamps-flag nil)
                              '(org-html-head-extra (concat "<style type=\"text/css\">"
                                                            "<!--/*--><![CDATA[/*><!--*/"
                                                            "pre.src {overflow-x: auto; }"
                                                            ".src { background-color: #f5deb3; color: #black;}"
                                                            "/*]]>*/-->"
                                                            "</style>"))))

    #+end_src
*** Org-babel
    #+begin_src emacs-lisp
      (use-package ob-core                         ;org-babel
        :after org
        :defer
        :config
        (custom-set-variables '(org-babel-min-lines-for-block-output 999)
                              '(org-babel-results-keyword "results"))

        (org-babel-do-load-languages 'org-babel-load-languages '((ledger . t)
                                                                 (dot . t)
                                                                 (shell . t))))
    #+end_src
*** Capture templates
    #+begin_src emacs-lisp
      (use-package org-capture
        :after org
        :bind (("C-c c" .  org-capture))
        :config
        (custom-set-variables '(org-default-notes-file "~/org/refile.org")
                              '(org-capture-templates '(("w" "Web" entry
                                                         (file "~/org/inbox.org")
                                                         "* %c :BOOKMARK:\n\n%i" :immediate-finish t)
                                                        ("t" "TODO" entry
                                                         (file+headline "~/org/inbox.org" "Incoming")
                                                         "* TODO %?\n  :PROPERTIES:\n  :CREATED: %U\n  :LINK: %a\n  :END:\n %i"
                                                         :clock-in t :clock-resume t)
                                                        ("n" "note" entry
                                                         (file "~/org/inbox.org")
                                                         "* %? :NOTE:\n  %U\n  %a\n"
                                                         :clock-in t :clock-resume t)
                                                        ("j" "journal" entry
                                                         (file+olp+datetree "~/org/journal.org" "Daily Notes")
                                                         "* %?\nEntered on %U\n  %i\n  %a")
                                                        ("q" "Quick note" item
                                                         (file+headline "~/org/review.org" "Quick notes"))
                                                        ("c" "Quick note on clocked task" item
                                                         (clock))))))

    #+end_src
*** Handling TODO items
    The following code sets up my TODO policy:
    - You cannot complete a task until all its sub tasks and check lists are
       completed
    - There are 5 types of TODO state flows:
      * TODO -> NEXT -> DONE
      * WAITING -> (HOLD | CANCELLED | PHONE | MEETING)
      * QUOTE -> QUOTED -> (APPROVED | EXPIRED | REJECTED)
      * OPEN -> (CLOSED)
      * PERIODIC -> DONE -> PERIODIC

    #+begin_src emacs-lisp
      (use-package org
        :config
        (custom-set-variables '(org-enforce-todo-checkbox-dependencies t)
                              '(org-enforce-todo-dependencies t)
                              '(org-use-fast-todo-selection t)
                              '(org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
                                                    (sequence "WAITING(w@/!)" "|" "HOLD(h@/!)" "CANCELLED(c@/!)" "PHONE" "MEETING")
                                                    (sequence "QUOTE(q!)" "QUOTED(Q!)" "|" "APPROVED(A@)" "EXPIRED(E@)" "REJECTED(R@)")
                                                    (sequence "OPEN(O)" "|" "CLOSED(C)")
                                                    (type "PERIODIC(P)" "|" "DONE(d!/!)")))
                              '(org-todo-keyword-faces '(("TODO"      :foreground "red"          :weight bold)
                                                         ("PERIODIC"  :foreground "magenta"      :weight bold)
                                                         ("NEXT"      :foreground "blue"         :weight bold)
                                                         ("DONE"      :foreground "forest green" :weight bold)
                                                         ("WAITING"   :foreground "yellow"       :weight bold)
                                                         ("HOLD"      :foreground "goldenrod"    :weight bold)
                                                         ("CANCELLED" :foreground "orangered"    :weight bold)
                                                         ("PHONE"     :foreground "forest green" :weight bold)
                                                         ("MEETING"   :foreground "forest green" :weight bold)
                                                         ("QUOTE"     :foreground "hotpink"      :weight bold)
                                                         ("QUOTED"    :foreground "indianred1"   :weight bold)
                                                         ("APPROVED"  :foreground "forest green" :weight bold)
                                                         ("EXPIRED"   :foreground "olivedrab1"   :weight bold)
                                                         ("REJECTED"  :foreground "olivedrab"    :weight bold)
                                                         ("OPEN"      :foreground "magenta"      :weight bold)
                                                         ("CLOSED"    :foreground "forest green" :weight bold)))
                              '(org-todo-state-tags-triggers '(("CANCELLED" ("CANCELLED" . t))
                                                               ("WAITING" ("WAITING" . t))
                                                               ("HOLD" ("WAITING" . t) ("HOLD" . t))
                                                               (done ("WAITING") ("HOLD"))
                                                               ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                                                               ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                                                               ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))


                              )

        )
    #+end_src

    *TODO* I think what I have right now is a little complicated.
    *TODO* What do those ~org-todo-state-tags-triggers~ guys do? Simplify?
*** Habit tracking

    #+begin_src emacs-lisp
      (use-package org-habit
        :after org-agenda
        :defer
        :config
        (custom-set-variables '(org-habit-graph-column 80)
                              '(org-habit-show-habits-only-for-today nil)))

    #+end_src

*** Refile

    For now I will only make a simple setup. I may extend with ideas from
    https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html
    #+begin_src emacs-lisp
      (use-package org
        :config
        (customize-set-value 'org-refile-use-outline-path 'file)
        ;; makes org-refile outline working with helm/ivy
        (customize-set-value 'org-outline-path-complete-in-steps nil)
        (customize-set-value 'org-refile-allow-creating-parent-nodes 'confirm))
    #+end_src
*** Eye candy
   I want variable pitch fonts in org mode. I also want a little eye candy on headings.

   #+begin_src emacs-lisp
     (use-package org
       :hook ((org-mode . (lambda () (set-buffer-variable-pitch 'org-table 'org-code 'org-block 'org-meta-line)))))

     (use-package org-superstar
       :ensure t
       :hook ((org-mode . org-superstar-mode))
       :config
       (custom-set-variables '(org-superstar-remove-leading-stars nil)
                             '(org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✚" "✜" "◆" "◇" "▶"))))
   #+end_src
*** Task clocking

    Main configuration concerns:
    - Keep history long: last 28 items
    - Resume clocking task on clock-in if the clock is open
    - Save clock data in the CLOCK drawer and state changes and notes in the LOGBOOK drawer
    - Remove 0:00 duration clock info from tasks
    - Clock out when moving task to DONE
    - Try to persist running clocks
    - Try to find open clocks
    - Include current clocking task in clock reports
    - Change task state to NEXT from TODO when clocking in

    #+begin_src emacs-lisp
      (use-package org-clock
        :after org
        :bind (("C-c C-x C-j" . org-clock-goto))
        :config
        (require 'org-helper)

        (custom-set-variables '(org-clock-persist t)
                              '(org-clock-history-length 28)
                              '(org-clock-in-resume t)
                              '(org-clock-into-drawer "CLOCK")
                              '(org-clock-out-remove-zero-time-clocks t)
                              '(org-clock-out-when-done t)
                              '(org-clock-persist t)
                              '(org-clock-auto-clock-resolution 'when-no-clock-is-running)
                              '(org-clock-report-include-clocking-task t)
                              '(org-clock-in-switch-to-state 'bh/clock-in-to-next)
                              '(org-clock-modeline-total 'current))
        (org-clock-persistence-insinuate)
        (org-clock-load))
    #+end_src

*** DISABLED Quantified self
    I've abandoned planning, but I will come back to it with a different
    workflow that works for me. I don't want to lose my previous work in the
    meantime.

    #+begin_src emacs-lisp :tangle no
      (use-package quantified
        :commands (quantified-text quantified-track quantified-share-org-subtree quantified-summarize-time)
        :config
        ;; Load my passwords so that I can login to quantified awesome
        (require 'secrets))
    #+end_src

*** DISABLED Org-mobile
    #+begin_src emacs-lisp :tangle no
      (use-package org-mobile
        :commands (org-mobile-push org-mobile-pull)
        :config (setq org-mobile-directory "~/outgoing/mobileorg"))
    #+end_src
** Diary
   #+begin_src emacs-lisp
     (use-package diary-lib
       :defer
       :config
       (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
       (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
       (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files))
   #+end_src
** Ledger mode

   Accounting from within emacs.

   #+begin_src emacs-lisp
     (use-package ledger-mode
       :ensure t
       :commands ledger-mode
       :config
       (add-hook 'ledger-mode-hook (lambda ()
                                     (setq ledger-post-account-alignment-column 2
                                           ledger-clear-whole-transactions t
                                           ledger-complete-ignore-case t
                                           ledger-highlight-xact-under-point nil)))

       (defadvice ledger-add-transaction (after remove-extra-newlines activate)
         "Clip the ever-growing \n series at end of file"
         (when (looking-at "\n\n\n")
           (delete-char 2))))
   #+end_src
** Dictionary

   It is good to have a dictionary handy. I've installed the package =sdcv=
   using ~sudo apt install sdcv~, and added Webster's last free version of the
   dictionary - which is one of the most poetic dictionaries out there.

   You can download the 1913 version from [[https://s3.amazonaws.com/jsomers/dictionary.zip][this archive from S3]]. Installatoin instructions
   (including the S3 archive location), and an interesting blog post is [[http://jsomers.net/blog/dictionary][here]].

   #+begin_src emacs-lisp
     (use-package sdcv-mode
       :defer
       :bind ( ("C-c C-d" . sdcv-search)))
   #+end_src
** Edit grep/occur buffers
   It is useful for mass editing.

   #+begin_src emacs-lisp
     (use-package wgrep
       :ensure t)
   #+end_src
** Per machine setup

   I may need to tweak some variables on individual machines, or leave some
   sensitive data outside my git repository. This section handles loading the
   machine setup.

   It has to be the last thing we do before we are finished, so that the
   per-machine script can override everything.

   #+begin_src emacs-lisp
     (let ((local-config-file "~/.emacs-local-config.el"))
       (when (file-exists-p local-config-file)
         (load-file local-config-file)))
   #+end_src
** Docker

   #+begin_src emacs-lisp
     (use-package dockerfile-mode
       :ensure t)
   #+end_src
** Non-text viewing and processing
   PDF reading and annotating
   ~pdf-tools~ allow better interaction with PDF documents
   #+begin_src emacs-lisp
   (use-package pdf-tools
     :ensure t
     :config
     (custom-set-variables '(pdf-info-epdfinfo-program "/usr/bin/epdfinfo")))
   #+end_src

   EPUB reading (org links missing)
   #+begin_src emacs-lisp
     (use-package nov
       :mode ("\\.epub\\'" . nov-mode)
       :ensure t)
   #+end_src
** News and Entertainment

   My favorite RSS reader. Contains small hooks for case insensitive searching.

   #+begin_src emacs-lisp
     (use-package elfeed-org
       :ensure t
       :config
       (elfeed-org)
       (custom-set-variables '(rmh-elfeed-org-files '("~/org/feeds.org"))))

     (defun elfeed-search-case-fold (orig-fun &rest args)
       (let ((case-fold-search t))
         (apply orig-fun args)))

     (defun elfeed-search-compile-case-fold (orig-fun &rest args)
       (let ((filter (apply orig-fun args)))
         `(lambda (entry feed count) (let ((case-fold-search t))
                                       ,@(cddr filter)))))

     (defun vh/elfeed-tag-untag-junk (arg)
       "Mark a post as junk.

     When marking as junk, we also remove the unread tag. With prefix
     argument, this function removes the junk tag (but doesn't add unread tag)."
       (interactive "p")
       (if (eq arg 4)
           (elfeed-search-untag-all 'junk)
         (let ((elfeed-search-remain-on-entry t))
           (elfeed-search-tag-all 'junk))
         (elfeed-search-untag-all 'unread)))

     (use-package elfeed
       :ensure t
       :bind (:map elfeed-show-mode-map
                   ("<tab>" . shr-next-link)
                   :map elfeed-search-mode-map
                   ("j" . vh/elfeed-tag-untag-junk))
       :hook (elfeed-show-mode . (lambda ()
                                   (make-local-variable 'shr-current-font)
                                   (setq shr-current-font 'large-variable-pitch)))

       :config
       (customize-set-value 'elfeed-search-filter "-junk @6-months-ago +unread")
       (advice-add #'elfeed-search-filter :around #'elfeed-search-case-fold)
       (advice-add #'elfeed-search-compile-filter :around #'elfeed-search-compile-case-fold))
   #+end_src

   I also check hackernews.

   #+begin_src emacs-lisp
     (use-package hackernews
       :ensure t)
   #+end_src
** Browse web inside editor
   Small tweaks for eww and w3m.

   I am not sure what ~shr-folding-mode~ does. I've seen two side-effects:

   1. It reduces empty lines around some headings
   2. It doesn't render some titles in bold

   Overall it seemed to make things a little more readable, so I am keeping it.

   #+begin_src emacs-lisp
     (use-package eww
       :ensure t
       :hook ((eww-mode . set-buffer-variable-pitch))
       :config
       (customize-set-variable 'eww-search-prefix "https://startpage.com/do/search?prf=95fa00857b1c3634f33a56a3f0f7e96b&query="))

     (use-package shr
       :config
       (setq shr-bullet "• "
             shr-folding-mode t))

     (use-package w3m
       :defer t
       :ensure t
       :init                                 ; shouldn't this be :config? Check with gnus
       (custom-set-variables '(w3m-use-tab-line nil)))

     (use-package url-cookie
       :config
       (custom-set-variables '(url-cookie-trusted-urls '())
                             '(url-cookie-untrusted-urls '(".*"))))
   #+end_src
* Final tweaks
